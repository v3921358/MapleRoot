declare namespace java {
    namespace lang {
        type Enum = any;
        type Runnable = any;
        type Throwable = any;
		type Integer = any;
		type Short = any;
    }
    namespace util {
        type Map = any;
        type Set = any;
        type List = any;
        type Iterator = any;
        type Collection = any;
        type HashMap = any;
        type ArrayList = any;
        type LinkedList = any;
        type HashSet = any;
        type TreeSet = any;
        type Stack = any;
        type Vector = any;
        type Calendar = any;
        type Optional = any;

        namespace concurrent {
            type ScheduledFuture = any;
        }

        namespace regex {
            type Pattern = any;
            type Matcher = any;
        }
    }
    namespace io {}
    namespace net {
		type InetAddress = any;
	}
    namespace sql {
        type Connection = any;
        type PreparedStatement = any;
        type ResultSet = any;
        type Timestamp = any;
    }
    namespace awt {
        interface Point {
            x: number;
            y: number;
            equals(): boolean;
            toString(): string;
            getLocation(): java.awt.Point;
            move(x: number, y: number): void;
            getX(): number;
            getY(): number;
            setLocation(p: java.awt.Point): void;
            setLocation(x: number, y: number): void;
            translate(dx: number, dy: number): void;
        }

        interface Rectangle {
            x: number;
            y: number;
            width: number;
            height: number;
            equals(): boolean;
            toString(): string;
            getLocation(): java.awt.Point;
            getSize(): java.awt.Dimension;
            move(x: number, y: number): void;
            resize(width: number, height: number): void;
            getX(): number;
            getY(): number;
            getWidth(): number;
            getHeight(): number;
            setLocation(p: java.awt.Point): void;
            setLocation(x: number, y: number): void;
            setSize(d: java.awt.Dimension): void;
            setSize(width: number, height: number): void;
            contains(p: java.awt.Point): boolean;
            contains(x: number, y: number): boolean;
            contains(r: java.awt.Rectangle): boolean;
            intersects(r: java.awt.Rectangle): boolean;
            union(r: java.awt.Rectangle): java.awt.Rectangle;
            add(p: java.awt.Point): void;
            add(r: java.awt.Rectangle): void;
            subtract(r: java.awt.Rectangle): void;
            translate(dx: number, dy: number): void;
        }

        interface Dimension {
            width: number;
            height: number;
            equals(): boolean;
            toString(): string;
            getSize(): java.awt.Dimension;
            resize(width: number, height: number): void;
            getWidth(): number;
            getHeight(): number;
            setSize(d: java.awt.Dimension): void;
            setSize(width: number, height: number): void;
            contains(p: java.awt.Point): boolean;
            contains(x: number, y: number): boolean;
            contains(r: java.awt.Rectangle): boolean;
            intersects(r: java.awt.Rectangle): boolean;
            union(r: java.awt.Rectangle): java.awt.Rectangle;
            add(p: java.awt.Point): void;
            add(r: java.awt.Rectangle): void;
            subtract(r: java.awt.Rectangle): void;
            translate(dx: number, dy: number): void;
        }
    }
    namespace security {}
    namespace text {}
    namespace nio {}
    namespace math {}
    namespace time {
        type Instant = any;
        type Duration = any;
    }
}
declare namespace javax {
    namespace script {
        type Invocable = any;
        type ScriptEngine = any;
    }
}
type ChannelHandlerContext = any;

interface InventoryManipulator {
	add(c: Client, item: Item): boolean;
	add(c: Client, item: Item, show: boolean, petId: number): boolean;
	add(c: Client, item: Item, show: boolean): boolean;
	move(c: Client, type: InventoryType, src: number, dst: number): void;
	drop(pet: Client, petIdx: InventoryType, target: number, c: number): void;
	checkSpaceProgressively(): number;
	addById(c: Client, itemId: number, quantity: number, owner: string, petid: number): boolean;
	addById(c: Client, itemId: number, quantity: number, owner: string, petid: number, expiration: number): boolean;
	addById(c: Client, itemId: number, quantity: number, expiration: number): boolean;
	addById(c: Client, itemId: number, quantity: number): boolean;
	addById(c: Client, itemId: number, quantity: number, owner: string, petid: number, flag: number, expiration: number): boolean;
	isSandboxItem(it: Item): boolean;
	addFromDrop(c: Client, item: Item, show: boolean): boolean;
	addFromDrop(c: Client, item: Item): boolean;
	addFromDrop(c: Client, item: Item, show: boolean, petId: number): boolean;
	removeFromSlot(c: Client, type: InventoryType, slot: number, quantity: number, fromDrop: boolean): void;
	removeFromSlot(pet: Client, petIdx: InventoryType, petid: number, c: number, type: boolean, slot: boolean): void;
	unequip(c: Client, src: number, dst: number): void;
	equip(flag: Client, top: number, bottom: number): void;
	checkSpace(numSlotsNeeded: Client, newQ: number, oldQ: number, eItem: string): boolean;
	removeById(item: Client, i: InventoryType, c: number, type: number, itemId: boolean, quantity: boolean): void;
}
interface ItemInformationProvider {
	getName(itemId: number): string;
	getInstance(): ItemInformationProvider;
	getInventoryType(itemId: number): InventoryType;
	isCash(itemId: number): boolean;
	getWholePrice(itemId: number): number;
	getUnitPrice(itemId: number): number;
	improveEquipStats(stat: Equip, fail: boolean): void;
	improveEquipStats(stat: Equip, nEquip: java.util.Map): void;
	rollSuccessChance(propPercent: number): boolean;
	canUseCleanSlate(nEquip: Equip): boolean;
	getEquipStats(): java.util.Map;
	getEquipById(equipId: number): Item;
	getEquipByIdAsEquip(equipId: number): Equip;
	isLootRestricted(): boolean;
	isQuestItem(itemId: number): boolean;
	getEquipLevelReq(): number;
	getWeaponType(itemId: number): WeaponType;
	getEquipmentSlot(itemId: number): string;
	isUntradeableRestricted(): boolean;
	getIsItemRestrictedByPlayerReborns(rebirths: number, itemId: number): boolean;
	isAccountRestricted(): boolean;
	getWatkForProjectile(itemId: number): number;
	scrollOptionEquipWithChaos(nEquip: Equip, range: number, option: boolean): void;
	isUntradeableOnEquip(itemId: number): boolean;
	getItemLevelupStats(): null[];
	getMakerReagentStatUpgrade(statGain: number): Pair;
	getMakerCrystalFromLeftover(rs: number): number;
	randomizeUpgradeStats(equip: Equip): Equip;
	getScriptedItemInfo(itemId: number): ScriptedItem;
	getAllItems(): null[];
	getSkillStats(): java.util.Map;
	noCancelMouse(itemId: number): boolean;
	getItemIdsInRange(): null[];
	getSlotMax(): number;
	getAllEtcItems(): null[];
	getReplaceOnExpire(itemId: number): Pair;
	getPrice(itemId: number, quantity: number): number;
	getScrollReqs(): null[];
	getMeso(itemId: number): number;
	getMsg(itemId: number): string;
	isDropRestricted(itemId: number): boolean;
	getItemEffect(spec: number): StatEffect;
	randomizeStats(equip: Equip): Equip;
	scrollEquipWithId(): Item;
	getSummonMobs(): number[][];
	getStateChangeItem(): number;
	getCreateItem(): number;
	getMobItem(): number;
	canPetConsume(npe: number, itemName: number): Pair;
	getCardMobId(id: number): number;
	isPickupRestricted(): boolean;
	isPartyQuestItem(itemId: number): boolean;
	isKarmaAble(itemId: number): boolean;
	isConsumeOnPickup(itemId: number): boolean;
	isUnmerchable(itemId: number): boolean;
	getMaxLevelById(): number;
	getItemReward(child: number): Pair;
	canWearEquipment(): boolean;
	canWearEquipment(item: Character, equip: null[]): null[];
	getExpById(): number;
	isTwoHanded(itemId: number): boolean;
	getUseDelay(): number;
	getMobHP(): number;
	isUpgradeable(itemId: number): boolean;
	getItemDataByName(): null[];
	getEquipLevel(curLevel: number, data2: boolean): number;
	getMakerItemEntry(ps: number): MakerItemCreateEntry;
	statItem(equip: Equip, str: number, dex: number, luk: number, int_: number): Equip;
	statItem(equip: Equip, str: number, dex: number, luk: number, int_: number, matk: number, watk: number, acc: number, avoid: number, jump: number, speed: number, wdef: number, mdef: number, hp: number, mp: number, upgradeSlots: number): Equip;
	getMakerStimulant(md: number): number;
	getBodyRelMove(): java.awt.Point;
	getWhoDrops(rs: number): java.util.Set;
	usableMasteryBooks(): null[];
	usableSkillBooks(): null[];
	getMakerStimulantFromEquip(): number;
	getQuestConsumablesInfo(qty: number): QuestConsItem;
	getMakerDisassembledFee(rs: number): number;
	getMakerCrystalFromEquip(): number;
	getMakerDisassembledItems(ps: number): null[];
}
interface StatEffect {
	isActive(applyto: Character): boolean;
	getDuration(vip: boolean): number;
	loadItemEffectFromData(source: Data, itemid: number): StatEffect;
	getWatk(): number;
	getMatk(): number;
	getHp(): number;
	getMp(): number;
	getX(): number;
	applyTo(chr: Character, useMaxRange: boolean): boolean;
	applyTo(chr: Character, useMaxRange: boolean, vip: boolean): boolean;
	applyTo(chr: Character, pos: java.awt.Point): boolean;
	applyTo(chr: Character): boolean;
	getCooldown(): number;
	isSkill(): boolean;
	getBuffSourceId(): number;
	getSourceId(): number;
	getStatups(): null[];
	isMapChair(): boolean;
	isMapChair(sourceid: number): boolean;
	isMonsterRiding(): boolean;
	isRecovery(): boolean;
	getHpRRate(): number;
	updateBuffEffect(target: Character, activeStats: null[], starttime: number, vip: boolean): void;
	isDragonBlood(): boolean;
	isBerserk(): boolean;
	isBeholder(): boolean;
	getHpR(): number;
	getMpRRate(): number;
	getMpR(): number;
	getCardRate(mapid: number, itemid: number): number;
	isMagicDoor(): boolean;
	loadSkillEffectFromData(source: Data, skillid: number, overtime: boolean): StatEffect;
	isMorphWithoutAttack(): boolean;
	getBuffLocalDuration(vip: boolean): number;
	getY(): number;
	silentApplyBuff(): void;
	isHpMpRecovery(sourceid: number): boolean;
	isMorph(): boolean;
	makeChanceResult(): boolean;
	getBulletConsume(): number;
	getMonsterStati(): java.util.Map;
	isPoison(): boolean;
	isAriantShield(sourceid: number): boolean;
	applyEchoOfHero(): boolean;
	applyPassive(): void;
	isHerosWill(skillid: number): boolean;
	applyComboBuff(applyto: Character, combo: number): void;
	getMpCon(): number;
	getDamage(): number;
	getAttackCount(): number;
	getMobCount(): number;
	getFixDamage(): number;
	getHpRate(): number;
	getHpCon(): number;
	setDuration(duration: number): void;
	applyBeaconBuff(applyto: Character, objectid: number): void;
	sameSource(effect: StatEffect): boolean;
	getMpRate(): number;
	getBulletCount(): number;
	getMoneyCon(): number;
}
interface Data {
	getName(): string;
	getType(): DataType;
	getChildren(): null[];
	getData(): object;
	getChildByPath(): Data;
}
interface DataType {
	NONE: DataType;
	IMG_0x00: DataType;
	SHORT: DataType;
	INT: DataType;
	FLOAT: DataType;
	DOUBLE: DataType;
	STRING: DataType;
	EXTENDED: DataType;
	PROPERTY: DataType;
	CANVAS: DataType;
	VECTOR: DataType;
	CONVEX: DataType;
	SOUND: DataType;
	UOL: DataType;
	UNKNOWN_TYPE: DataType;
	UNKNOWN_EXTENDED_TYPE: DataType;
	values(): DataType[];
	valueOf(name: string): DataType;
}
interface Item {
	toString(): string;
	compareTo(other: Item): number;
	compareTo(): number;
	copy(): Item;
	getOwner(): string;
	setOwner(owner: string): void;
	getInventoryType(): InventoryType;
	getQuantity(): number;
	getExpiration(): number;
	setExpiration(expire: number): void;
	getGiftFrom(): string;
	setGiftFrom(giftFrom: string): void;
	getItemType(): number;
	getPetId(): number;
	setSN(sn: number): void;
	getPet(): Pet;
	getItemLog(): null[];
	getSN(): number;
	isUntradeable(): boolean;
	setPosition(position: number): void;
	getCashId(): number;
	getItemId(): number;
	getFlag(): number;
	setQuantity(quantity: number): void;
	setFlag(b: number): void;
	getPosition(): number;
}
interface Equip extends Item {
	getInt(): number;
	setInt(_int: number): void;
	copy(): Item;
	getLevel(): number;
	setLevel(level: number): void;
	setStr(str: number): void;
	getStr(): number;
	gainStats(statUp: null[]): Pair;
	setHands(hands: number): void;
	gainItemExp(c: Client, gain: number): void;
	setVicious(vicious: number): void;
	setVicious(i: number): void;
	getStats(): java.util.Map;
	getItemExp(): number;
	getItemType(): number;
	getHands(): number;
	showEquipFeatures(c: Client): string;
	setItemLevel(level: number): void;
	setRingId(id: number): void;
	isWearing(): boolean;
	setItemExp(exp: number): void;
	getRingId(): number;
	getItemLevel(): number;
	setAcc(acc: number): void;
	getWatk(): number;
	getDex(): number;
	getMatk(): number;
	setWdef(wdef: number): void;
	getHp(): number;
	setSpeed(speed: number): void;
	getAvoid(): number;
	getMdef(): number;
	getVicious(): number;
	getLuk(): number;
	getSpeed(): number;
	setMdef(mdef: number): void;
	setLuk(luk: number): void;
	setAvoid(avoid: number): void;
	getJump(): number;
	setHp(hp: number): void;
	setMp(mp: number): void;
	getUpgradeSlots(): number;
	setWatk(watk: number): void;
	getWdef(): number;
	getAcc(): number;
	setMatk(matk: number): void;
	setJump(jump: number): void;
	setDex(dex: number): void;
	getMp(): number;
	setUpgradeSlots(upgradeSlots: number): void;
	setUpgradeSlots(i: number): void;
	getFlag(): number;
	setQuantity(quantity: number): void;
	setFlag(flag: number): void;
	wear(yes: boolean): void;
}
interface QuestConsItem {
	questid: number;
	exp: number;
	grade: number;
	items: java.util.Map;
	getItemRequirement(itemid: number): number;
}
interface CardItemupStats {
}
interface Pet extends Item {
	getName(): string;
	setName(name: string): void;
	getLevel(): number;
	setLevel(level: number): void;
	loadFromDb(rs: number, ps: number, con: number): Pet;
	setStance(stance: number): void;
	gainTamenessFullness(): void;
	gainTamenessFullness(owner: Character, incTameness: number, incFullness: number, type: number): void;
	getTameness(): number;
	getPetAttribute(): number;
	setTameness(tameness: number): void;
	setPos(pos: java.awt.Point): void;
	removePetAttribute(owner: Character, flag: PetAttribute): void;
	canConsume(itemId: number): Pair;
	updatePosition(): void;
	addPetAttribute(owner: Character, flag: PetAttribute): void;
	deleteFromDb(ps: Character, con: number): void;
	setUniqueId(id: number): void;
	getPos(): java.awt.Point;
	createPet(ret: number, ps: number, con: number, e: number): number;
	createPet(ret: number): number;
	setFh(Fh: number): void;
	getUniqueId(): number;
	isSummoned(): boolean;
	saveToDb(): void;
	getFullness(): number;
	setFullness(fullness: number): void;
	setSummoned(yes: boolean): void;
	getFh(): number;
	getStance(): number;
}
interface PetAttribute {
	OWNER_SPEED: PetAttribute;
	values(): PetAttribute[];
	valueOf(name: string): PetAttribute;
	getValue(): number;
}
interface ScrollResult {
	FAIL: ScrollResult;
	SUCCESS: ScrollResult;
	CURSE: ScrollResult;
	values(): ScrollResult[];
	valueOf(name: string): ScrollResult;
	getValue(): number;
}
interface StatUpgrade {
	incDEX: StatUpgrade;
	incSTR: StatUpgrade;
	incINT: StatUpgrade;
	incLUK: StatUpgrade;
	incMHP: StatUpgrade;
	incMMP: StatUpgrade;
	incPAD: StatUpgrade;
	incMAD: StatUpgrade;
	incPDD: StatUpgrade;
	incMDD: StatUpgrade;
	incEVA: StatUpgrade;
	incACC: StatUpgrade;
	incSpeed: StatUpgrade;
	incJump: StatUpgrade;
	incVicious: StatUpgrade;
	incSlot: StatUpgrade;
	values(): StatUpgrade[];
	valueOf(name: string): StatUpgrade;
}
interface Client {
	LOGIN_NOTLOGGEDIN: number;
	LOGIN_SERVER_TRANSITION: number;
	LOGIN_LOGGEDIN: number;
	getType(): Type;
	getLanguage(): number;
	getChannel(): number;
	checkChar(w: number): void;
	setLanguage(lingua: number): void;
	getPlayer(): Character;
	updateMainCharacterId(connectionOwned: number, e: java.sql.Connection): boolean;
	loseBurningCharacter(): boolean;
	loseBurningCharacter(closeCon: java.sql.Connection): boolean;
	canGainCharacterSlot(): boolean;
	createChannelClient(sessionId: number, remoteAddress: string, packetProcessor: PacketProcessor, world: number, channel: number): Client;
	getAvailableCharacterSlots(): number;
	announceServerMessage(): void;
	getTempBanCalendarFromDB(): java.util.Calendar;
	gainBurningCharacter(): boolean;
	gainBurningCharacter(closeCon: java.sql.Connection): boolean;
	requestedServerlist(worlds: number): void;
	closePlayerScriptInteractions(): void;
	getAvailableCharacterWorldSlots(): number;
	getAvailableCharacterWorldSlots(world: number): number;
	getBurningCharacters(): number;
	setBurningCharacters(chars: number): void;
	getAbstractPlayerInteraction(): AbstractPlayerInteraction;
	getHwid(): Hwid;
	channelActive(ctx: ChannelHandlerContext): void;
	channelInactive(ctx: ChannelHandlerContext): void;
	createLoginClient(sessionId: number, remoteAddress: string, packetProcessor: PacketProcessor, world: number, channel: number): Client;
	resetCsCoupon(): void;
	disconnectSession(): void;
	channelRead(result: ChannelHandlerContext, chrInfo: object): void;
	getLastPacket(): number;
	isInTransition(): boolean;
	createMock(): Client;
	userEventTriggered(): void;
	exceptionCaught(ctx: ChannelHandlerContext, cause: java.lang.Throwable): void;
	setHwid(hwid: Hwid): void;
	sendCharList(server: number): void;
	sendPacket(packet: Packet): void;
	getAccountName(): string;
	updateLastPacket(): void;
	getRemoteAddress(): string;
	getEventManager(event: string): EventManager;
	getChannelServer(channel: number): Channel;
	getChannelServer(): Channel;
	closeSession(): void;
	disconnect(shutdown: boolean, cashshop: boolean): void;
	checkIfIdle(event: IdleStateEvent): void;
	getAccID(): number;
	getVoteTime(): number;
	updateLoginState(con: number): void;
	getLoginState(): number;
	canBypassPic(): boolean;
	canBypassPin(): boolean;
	setAccID(id: number): void;
	getWorldServer(): World;
	isLoggedIn(): boolean;
	setPlayer(player: Character): void;
	getQM(): QuestActionManager;
	unlockClient(): void;
	forceDisconnect(): void;
	lockClient(): void;
	getCM(): NPCConversationManager;
	removeClickedNPC(): void;
	setClickedNPC(): void;
	getWorld(): number;
	setCharacterOnSessionTransitionState(cid: number): void;
	setPin(con: string): void;
	setPic(con: string): void;
	loadCharacterNames(): null[];
	getPin(): string;
	getPic(): string;
	hasVotedAlready(): boolean;
	hasBannedMac(): boolean;
	finishLogin(): number;
	banHWID(): void;
	checkPin(other: string): boolean;
	banMacs(): void;
	hasBannedIP(): boolean;
	resetVoteTime(): void;
	hasBannedHWID(): boolean;
	checkPic(other: string): boolean;
	loadCharacters(e: number): null[];
	login(passhash: string, tos: string, rs: Hwid): number;
	updateMacs(ps: string): void;
	hasBeenBanned(): boolean;
	dottedQuadToLong(quad: string): number;
	getTempBanCalendar(): java.util.Calendar;
	updateHwid(con: Hwid): void;
	checkBirthDate(date: java.util.Calendar): boolean;
	setAccountName(a: string): void;
	getGMLevel(): number;
	pongReceived(): void;
	getMainCharacterId(): number;
	getScriptEngine(name: string): javax.script.ScriptEngine;
	getMacs(): java.util.Set;
	acceptToS(): boolean;
	getVotePoints(): number;
	setWorld(world: number): void;
	setMainCharacterId(mainCharacterId: number): void;
	removeScriptEngine(name: string): void;
	setChannel(channel: number): void;
	addVotePoints(points: number): void;
	setScriptEngine(name: string, e: javax.script.ScriptEngine): void;
	setGMLevel(level: number): void;
	useVotePoints(points: number): void;
	deleteCharacter(ps: number, con: number): boolean;
	getGReason(): number;
	getGender(): number;
	attemptCsCoupon(): boolean;
	tryacquireClient(): boolean;
	getSpamManager(): SpamManager;
	announceBossHpBar(mm: Monster, mobHash: number, packet: Packet): void;
	gainCharacterSlot(): boolean;
	changeChannel(): void;
	getSessionId(): number;
	unlockEncoder(): void;
	enableCSActions(): void;
	releaseClient(): void;
	setCharacterSlots(slots: number): void;
	announceHint(msg: string, length: number): void;
	canRequestCharlist(): boolean;
	setGender(con: number): void;
	canClickNPC(): boolean;
	getVisibleWorlds(): number;
	tryacquireEncoder(): boolean;
	getCharacterSlots(): number;
}
interface MakerItemFactory {
	generateDisassemblyCrystalEntry(p: number, fromEquipid: number, cost: null[]): MakerItemCreateEntry;
	generateLeftoverCrystalEntry(fromLeftoverid: number, crystalId: number): MakerItemCreateEntry;
	getMakerStimulantFee(itemId: number): number;
	getMakerReagentFee(itemId: number, eqpLevel: number): number;
	getItemCreateEntry(r: number, toCreate: number, stimulantid: java.util.Map): MakerItemCreateEntry;
}
interface MakerItemCreateEntry {
	isInvalid(): boolean;
	addCost(amount: number): void;
	trimCost(): void;
	getReqSkillLevel(): number;
	getReqLevel(): number;
	getReqItems(): null[];
	getCost(): number;
	getGainItems(): null[];
}
interface MakerService {
	removeOddMakerReagents(tableRid: number, curRid: java.util.Map): boolean;
	addBoostedMakerItem(c: Client, itemId: number, stimulantId: number, reagentIds: java.util.Map): boolean;
	addBoostedMakerItemSimple(c: Client, itemId: number, stimulantId: number, reagentIds: java.util.Map): boolean;
	getMakerReagentSlots(eqpLevel: number): number;
	generateDisassemblyInfo(gains: number): Pair;
	hasItems(itemId: Client, p: MakerItemCreateEntry): boolean;
	getMakerSkillLevel(chr: Character): number;
	getCreateStatus(c: Client, recipe: MakerItemCreateEntry): number;
	applyMakerResult(c: Client, createStatus: number, toCreate: number, recipe: MakerItemCreateEntry,
					 toDisassemble: number, pos: number, stimulationId: number, reagentIds: java.util.Map,
					 makerSucceeded: boolean, type: number): void;
}
interface PacketProcessor {
	topLoginOpcodeValue: number;
	topChannelOpcodeValue: number;
	reset(channel: number): void;
	getHandler(packetId: number): PacketHandler;
	getChannelServerProcessor(world: number, channel: number): PacketProcessor;
	getLoginServerProcessor(): PacketProcessor;
	registerHandler(): void;
	getProcessor(world: number, channel: number): PacketProcessor;
}
interface Packet {
	getBytes(): number[];
}
interface Channel {
	shutdown(): void;
	getId(): number;
	isActive(): boolean;
	freeDojoSectionIfEmpty(i: number): void;
	broadcastPacket(): void;
	getEventSM(): EventScriptManager;
	getWorldServer(): World;
	removePlayer(chr: Character): boolean;
	getServerMessage(): string;
	getPlayerStorage(): PlayerStorage;
	dropMessage(): void;
	getWorld(): number;
	addPlayer(chr: Character): void;
	removePlayerAway(chrId: number): void;
	insertPlayerAway(chrId: number): void;
	getMapFactory(): MapManager;
	getServiceAccess(sv: ChannelServices): BaseService;
	getDojoFinishTime(dojoMapId: number): number;
	getPartyMembers(partychar: Party): null[];
	addMiniDungeon(mmd: number): boolean;
	getExpedition(type: ExpeditionType): Expedition;
	finishedShutdown(): boolean;
	resetDojo(dojoMapId: number): void;
	isWeddingReserved(weddingId: number): boolean;
	ingressDojo(slotMapid: boolean, dojoSlot: Party, dojoList: number): number;
	ingressDojo(isPartyDojo: boolean, fromStage: number): number;
	setEvent(event: Event): void;
	getOngoingWedding(cathedral: boolean): number;
	getChannelCapacity(): number;
	getEvent(): Event;
	getIP(): string;
	canUninstall(): boolean;
	broadcastGMPacket(): void;
	multiBuddyFind(characterId: number, i: number[]): number[];
	resetDojoMap(): void;
	setDojoProgress(dojoMapId: number): boolean;
	lookupPartyDojo(party: Party): number;
	removeExpedition(exped: Expedition): void;
	addHiredMerchant(chrid: number, hm: HiredMerchant): void;
	setStoredVar(key: number, val: number): void;
	addExpedition(exped: Expedition): boolean;
	getExpeditions(): null[];
	setServerMessage(message: string): void;
	getHiredMerchants(): java.util.Map;
	getStoredVar(key: number): number;
	setOngoingWedding(): void;
	getMiniDungeon(dungeonid: number): MiniDungeon;
	removeMiniDungeon(dungeonid: number): void;
	registerOwnedMap(map: MapleMap): void;
	unregisterOwnedMap(map: MapleMap): void;
	initMonsterCarnival(cpq1: boolean, field: number): void;
	closeOngoingWedding(cathedral: boolean): void;
	isOngoingWeddingGuest(cathedral: boolean, playerId: number): boolean;
	getWeddingReservationStatus(): number;
	getRelativeWeddingTicketExpireTime(resSlot: number): number;
	reloadEventScriptManager(): void;
	acceptOngoingWedding(cathedral: boolean): boolean;
	getWeddingTicketExpireTime(resSlot: number): number;
	getWeddingCoupleForGuest(guestId: number, cathedral: boolean): Pair;
	pushWeddingReservation(): number;
	runCheckOwnedMapsSchedule(): void;
	finishMonsterCarnival(cpq1: boolean, field: number): void;
	debugMarriageStatus(): void;
	canInitMonsterCarnival(cpq1: boolean, field: number): boolean;
	getNextWeddingReservation(ret: boolean): Pair;
	getOngoingWeddingType(cathedral: boolean): boolean;
	getWeddingReservationTimeLeft(resStatus: number): string;
	removeHiredMerchant(chrid: number): void;
	dismissDojoSchedule(dojoMapId: number, party: Party): void;
	isConnected(name: string): boolean;
}
interface PacketHandler {
	getOpcode(): number;
	isEnableActionsRequired(): boolean;
	validateState(c: Client): boolean;
	getLimit(): number;
	handlePacket(p: InPacket, c: Client): void;
	getCooldown(): number;
}
interface Hwid {
	equals(o: object): boolean;
	toString(): string;
	hashCode(): number;
	hwid(): string;
	fromHostString(hostString: string): Hwid;
}
interface MapleMap {
	getId(): number;
	dispose(): void;
	broadcastUpdateCharLookMessage(): void;
	broadcastNONGMMessage(): void;
	findClosestPlayerSpawnpoint(portal: java.awt.Point): Portal;
	getRandomPlayerSpawnpoint(): Portal;
	updatePartyItemDropsToNewcomer(updatePacket: Character, mdrop: null[]): void;
	updatePlayerItemDropsToParty(): null[];
	broadcastPacket(source: Character, packet: Packet): void;
	getChannelServer(): Channel;
	getEventInstance(): EventInstanceManager;
	getCharacterById(): Character;
	getWorldServer(): World;
	removePlayer(summon: Character): void;
	getHPDec(): number;
	getFieldLimit(): number;
	dropMessage(type: number, message: string): void;
	broadcastGMMessage(source: Character, packet: Packet, repeatToSource: boolean): void;
	broadcastGMMessage(packet: Packet): void;
	getWorld(): number;
	broadcastSpawnPlayerMapObjectMessage(source: Character, player: Character, enteringField: boolean): void;
	getItems(): null[];
	movePlayer(visibleObjects: Character, mapObjects: java.awt.Point): void;
	getReturnMapId(): number;
	addPlayer(travelTime: Character): void;
	getEnvironment(): java.util.Map;
	pickItemDrop(pickupPacket: Packet, mdrop: MapItem): void;
	getHPDecProtect(): number;
	removePlayerPuppet(): void;
	removeMapObject(obj: MapObject): void;
	removeMapObject(num: number): void;
	getMoeBstFootholds(): PhysicalSpace2D;
	getPortal(portalid: number): Portal;
	getPortal(): Portal;
	addPlayerPuppet(): void;
	getMonsters(): null[];
	spawnSummon(summon: Summon): void;
	broadcastMessage(packet: Packet, rangedFrom: java.awt.Point): void;
	broadcastMessage(source: Character, packet: Packet, rangedFrom: java.awt.Point): void;
	broadcastMessage(source: Character, packet: Packet, repeatToSource: boolean, ranged: boolean): void;
	broadcastMessage(packet: Packet): void;
	broadcastMessage(source: Character, packet: Packet, repeatToSource: boolean): void;
	getAllPlayers(): null[];
	getAllPlayers(character: boolean): null[];
	getMapObjectsInRange(): null[];
	findMarketPortal(): Portal;
	countMonsters(): number;
	warpEveryone(): void;
	resetMapObjects(difficulty: number, isPq: boolean): void;
	resetMapObjects(): void;
	registerCharacterStatUpdate(r: java.lang.Runnable): void;
	getMapObjectsInRect(): null[];
	isTown(): boolean;
	getDeathCP(): number;
	respawn(): void;
	isCPQMap(): boolean;
	findClosestPortal(portal: java.awt.Point): Portal;
	getForcedReturnId(): number;
	startMapEffect(msg: string, itemId: number): void;
	startMapEffect(msg: string, itemId: number, time: number): void;
	setEventInstance(eim: EventInstanceManager): void;
	setGuess(guess: number): void;
	getGuess(): number;
	getMapPlayers(): java.util.Map;
	getReturnMap(): MapleMap;
	spawnDoor(door: DoorObject): void;
	getGroundBelow(pos: java.awt.Point): java.awt.Point;
	spawnMist(): void;
	broadcastGMSpawnPlayerMapObjectMessage(source: Character, player: Character, enteringField: boolean): void;
	changeEnvironment(mapObj: string, newState: number): void;
	addMapleArea(rec: java.awt.Rectangle): void;
	setMoeBstFootholds(footholds: PhysicalSpace2D): void;
	getAreas(): null[];
	addPortal(myPortal: Portal): void;
	getStreetName(): string;
	setClock(e: number): void;
	setClock(hasClock: boolean): void;
	setTown(isTown: boolean): void;
	removeMonsterSpawn(): void;
	setMuted(mute: boolean): void;
	setEverlast(everlast: boolean): void;
	getEverlast(): boolean;
	setMobCapacity(capacity: number): void;
	setBackgroundTypes(backTypes: java.util.HashMap): void;
	toggleEnvironment(ms: string): void;
	setMapName(mapName: string): void;
	setStreetName(streetName: string): void;
	instanceMapRespawn(): void;
	setEventStarted(event: boolean): void;
	setHPDecProtect(delta: number): void;
	getOnUserEnter(): string;
	getDocked(): boolean;
	setFieldType(fieldType: number): void;
	allowSummonState(b: boolean): void;
	setBoat(hasBoat: boolean): void;
	setSeats(seats: number): void;
	getSummonState(): boolean;
	setFieldLimit(fieldLimit: number): void;
	warpOutByTeam(): void;
	getEventNPC(): string;
	hasEventNPC(): boolean;
	isEventMap(): boolean;
	setOnUserEnter(onUserEnter: string): void;
	setTimeMob(id: number, msg: string): void;
	setHPDec(delta: number): void;
	setRecovery(recRate: number): void;
	getBlueTeamBuffs(): null[];
	setMaxReactors(maxReactors: number): void;
	getRedTeamBuffs(): null[];
	getTimeDefault(): number;
	broadcastShip(state: boolean): void;
	clearBuffList(): void;
	setMobInterval(interval: number): void;
	getMobInterval(): number;
	isCPQLoserMap(): boolean;
	getMaxReactors(): number;
	resetFully(): void;
	setMaxMobs(maxMobs: number): void;
	setDeathCP(deathCP: number): void;
	isPurpleCPQMap(): boolean;
	addSkillId(z: number): void;
	setTimeDefault(timeDefault: number): void;
	getMaxMobs(): number;
	toggleHiddenNPC(obj: number): void;
	addMobSpawn(mobId: number, spendCP: number): void;
	broadcastEnemyShip(state: boolean): void;
	isCPQWinnerMap(): boolean;
	claimOwnership(chr: Character): boolean;
	setTimeExpand(timeExpand: number): void;
	setBingo(bingo: Bingo): void;
	getBingo(): Bingo;
	setWordTrack(wordTrack: WordTrack): void;
	isBombs(): boolean;
	isAKEmpty(): boolean;
	addAK(ak: number, xy: boolean, side: boolean): void;
	clearAK(xy: boolean): void;
	getTimeExpand(): number;
	getKillOnHit(): boolean;
	getWordTrack(): WordTrack;
	setBombs(bombs: boolean): void;
	getCharacters(): null[];
	killAllMonsters(): void;
	isAllReactorState(): boolean;
	resetReactors(): void;
	spawnMonster(): void;
	spawnMonster(monster: Monster): void;
	addMapObject(mapobject: MapObject): void;
	countMonster(id: number): number;
	countMonster(): number;
	getMonsterById(): Monster;
	startEvent(chr: Character): void;
	startEvent(): void;
	getCharacterByName(): Character;
	getTimeLeft(): number;
	getTimeLimit(): number;
	broadcastGMPacket(source: Character, packet: Packet): void;
	removeParty(partyid: number): void;
	getMapName(): string;
	isCPQLobby(): boolean;
	getAllPlayer(): null[];
	getMapAllPlayers(): java.util.Map;
	getTimeMob(): Pair;
	killMonster(monster: Monster, chr: Character, withDrops: boolean): void;
	killMonster(): void;
	killMonster(character: Monster, mmo: Character, mii: boolean, mons: number): void;
	spawnFakeMonster(monster: Monster): void;
	moveMonster(): void;
	isHorntailDefeated(): boolean;
	dismissRemoveAfter(): void;
	isMuted(): boolean;
	getMapObject(oid: number): MapObject;
	getNPCById(obj: number): NPC;
	spawnMesoDrop(meso: number, position: java.awt.Point, dropper: MapObject, owner: Character, playerDrop: boolean, droptype: number): void;
	getMonsterByOid(oid: number): Monster;
	damageMonster(object: Character, killed: Monster, damageDivider: number, calcDamage: boolean): boolean;
	checkMapOwnerActivity(): void;
	getAggroCoordinator(): MonsterAggroCoordinator;
	broadcastBossHpMessage(mm: Monster, bossHash: number, packet: Packet, rangedFrom: java.awt.Point): void;
	broadcastBossHpMessage(mm: Monster, bossHash: number, packet: Packet): void;
	dropFromFriendlyMonster(chr: Character, mob: Monster): void;
	disappearingMesoDrop(meso: number, dropper: MapObject, owner: Character, pos: java.awt.Point): void;
	removeSelfDestructive(mapobjectid: number): boolean;
	isOwnershipRestricted(chr: Character): boolean;
	dropItemsFromMonster(list: null[], chr: Character, mob: Monster): void;
	spawnMonsterOnGroundBelow(id: number, x: number, y: number): void;
	spawnMonsterOnGroundBelow(mob: Monster, pos: java.awt.Point): void;
	findClosestTeleportPortal(portal: java.awt.Point): Portal;
	disappearingItemDrop(dropper: MapObject, owner: Character, item: Item, pos: java.awt.Point): void;
	getRoundedCoordinate(angle: number): string;
	makeDisappearItemFromMap(mapitem: MapItem): boolean;
	makeDisappearItemFromMap(mapobj: MapObject): boolean;
	runCharacterStatUpdate(): void;
	spawnAllMonsterIdFromMapSpawnList(id: number): void;
	spawnAllMonsterIdFromMapSpawnList(): void;
	closeMapSpawnPoints(): void;
	getNumPlayersItemsInRect(rect: java.awt.Rectangle): number;
	spawnAllMonstersFromMapSpawnList(): void;
	instanceMapFirstSpawn(): void;
	broadcastStringMessage(type: number, message: string): void;
	getRandomGuardianSpawn(gsp: number): GuardianSpawnPoint;
	spawnMonsterWithEffect(monster: Monster, effect: number, pos: java.awt.Point): void;
	getNumPlayersInRect(): number;
	restoreMapSpawnPoints(): void;
	getDoorPositionStatus(pos: java.awt.Point): Pair;
	broadcastHorntailVictory(): void;
	getOnFirstUserEnter(): string;
	getSpawnedMonstersOnMap(): number;
	getAnyCharacterFromParty(): Character;
	getDroppedItemsCountById(): number;
	broadcastKrexelVictory(): void;
	broadcastPinkBeanVictory(channel: number): void;
	removeAllMonsterSpawn(): void;
	reportMonsterSpawnPoints(): void;
	broadcastNightEffect(): void;
	broadcastBalrogVictory(leaderName: string): void;
	broadcastZakumVictory(): void;
	softKillAllMonsters(): void;
	getReactorsByIdRange(): null[];
	setMapPointBoundings(px: number, py: number, h: number, w: number): void;
	setAllowSpawnPointInBox(): void;
	setAllowSpawnPointInRange(): void;
	findClosestSpawnpoint(sp: java.awt.Point): SpawnPoint;
	getNumPlayersItemsInArea(index: number): number;
	broadcastChaosHorntailVictory(): void;
	spawnHorntailOnGroundBelow(mobId: java.awt.Point): void;
	addGuardianSpawnPoint(a: GuardianSpawnPoint): void;
	addPlayerNPCMapObject(pnpcobject: PlayerNPC): void;
	broadcastChaosZakumVictory(): void;
	killMonsterWithDrops(mob: number): void;
	setOnFirstUserEnter(onFirstUserEnter: string): void;
	generateMapDropRangeCache(): void;
	setMapLineBoundings(vrTop: number, vrBottom: number, vrLeft: number, vrRight: number): void;
	getNumPlayersInArea(index: number): number;
	getDroppedItemCount(): number;
	spawnChaosHorntailOnGroundBelow(mobId: java.awt.Point): void;
	killAllMonstersNotFriendly(): void;
	spawnFakeMonsterOnGroundBelow(mob: Monster, pos: java.awt.Point): void;
	instanceMapForceRespawn(): void;
	doKillOnHit(): boolean;
	calcDropPos(initial: java.awt.Point, fallback: java.awt.Point): java.awt.Point;
	spawnItemDrop(dropper: MapObject, owner: Character, item: Item, pos: java.awt.Point, ffaDrop: boolean, playerDrop: boolean): void;
	spawnItemDrop(dropper: MapObject, owner: Character, item: Item, pos: java.awt.Point, dropType: number, playerDrop: boolean): void;
	crossedAK(akY1: java.awt.Point): boolean;
	spawnKite(kite: Kite): void;
	getRecovery(): number;
	containsNPC(): boolean;
	getMapObjects(): null[];
	getSeats(): number;
	getReactorByOid(oid: number): Reactor;
	spawnCPQMonster(mob: Monster, pos: java.awt.Point, team: number): void;
	searchItemReactors(owner: Reactor): void;
	spawnRevives(monster: Monster): void;
	getReactorByName(): Reactor;
	spawnDojoMonster(monster: Monster): void;
	getPointBelow(pos: java.awt.Point): java.awt.Point;
	getDoorPortal(doorid: number): Portal;
	killFriendlies(mob: Monster): void;
	getCoconut(): Coconut;
	getSnowball(team: number): Snowball;
	getMobsToSpawn(): null[];
	addAllMonsterSpawn(monster: Monster, mobTime: number, team: number): void;
	getRandomSP(sp: number): java.awt.Point;
	getSkillIds(): null[];
	spawnGuardian(pt: number, reactorID: number): number;
	addMonsterSpawn(monster: Monster, mobTime: number, team: number): void;
	mobMpRecovery(): void;
	removePartyMember(chr: Character, partyid: number): void;
	addPartyMember(chr: Character, partyid: number): void;
	isOxQuiz(): boolean;
	killOnHit(hit: number): void;
	destroyReactor(oid: number): void;
	getReactors(): null[];
	getAllMonsters(): null[];
	addSelfDestructive(mob: Monster): void;
	makeMonsterReal(monster: Monster): void;
	isCPQMap2(): boolean;
	getPlayers(): null[];
	isStartingEventMap(): boolean;
	getArea(index: number): java.awt.Rectangle;
	eventStarted(): boolean;
	spawnItemDropList(): void;
	spawnItemDropList(list: null[], dropper: MapObject, owner: Character, pos: java.awt.Point): void;
	spawnItemDropList(list: null[], minCopies: number, maxCopies: number, dropper: MapObject, owner: Character, pos: java.awt.Point): void;
	hasClock(): boolean;
	unclaimOwnership(chr: Character): boolean;
	unclaimOwnership(): Character;
	setSnowball(team: number, ball: Snowball): void;
	sendNightEffect(): void;
	setOx(set: OxQuiz): void;
	getMapObjectsInBox(): null[];
	moveEnvironment(ms: string, type: number): void;
	getOx(): OxQuiz;
	setOxQuiz(b: boolean): void;
	setCoconut(nut: Coconut): void;
	clearMapObjects(): void;
	isBlueCPQMap(): boolean;
	clearDrops(): void;
	resetPQ(): void;
	resetPQ(difficulty: number): void;
	buffMonsters(): void;
	setDocked(isDocked: boolean): void;
	spawnReactor(reactor: Reactor): void;
	getForcedReturnMap(): MapleMap;
	setForcedReturnMap(map: number): void;
	getCurrentPartyId(): number;
	getMapArea(): java.awt.Rectangle;
	setTimeLimit(timeLimit: number): void;
	setReactorState(): void;
	limitReactor(obj: number, mr: number): void;
	toggleDrops(): void;
	canDeployDoor(pos: java.awt.Point): boolean;
	dropFromReactor(chr: Character, reactor: Reactor, drop: Item, dropPos: java.awt.Point, questid: number): void;
	countAlivePlayers(): number;
	getAllReactors(): null[];
	countReactors(): number;
	getPlayersInRange(): null[];
	countBosses(): number;
	countItems(): number;
	countPlayers(): number;
	shuffleReactors(ob: null[]): void;
	shuffleReactors(): void;
	shuffleReactors(obj: number, mr: number): void;
	destroyNPC(): void;
	destroyReactors(obj: number, mr: number): void;
	getReactorById(): Reactor;
	setSpawnRateMultiplier(spawnRateMultiplier: number): void;
	createMapTimer(timer:number): void;
	setExpRateMultiplier(expRateMultiplier: number): void;
	getExpRateMultiplier(): number;
}
interface Summon extends AbstractAnimatedMapObject {
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	getType(): MapObjectType;
	getOwner(): Character;
	getSkill(): number;
	getSkillLevel(): number;
	addHP(delta: number): void;
	isPuppet(): boolean;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	isStationary(): boolean;
	getMovementType(): SummonMovementType;
	getHP(): number;
}
interface AbstractAnimatedMapObject extends AbstractMapObject {
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	getIdleMovement(): InPacket;
	setStance(stance: number): void;
	getStance(): number;
	isFacingLeft(): boolean;
}
interface Snowball {
	message(): void;
	hit(what: number, damage: number): void;
	warpOut(): void;
	setSnowmanHP(hp: number): void;
	startEvent(): void;
	getSnowmanHP(): number;
	setHittable(hit: boolean): void;
	isHittable(): boolean;
	getPosition(): number;
}
interface SpamManager {
	checkSpam(player: Client, client: number, opcode: PacketHandler): boolean;
	addSpam(op: number): void;
	isSpam(op: number, handler: PacketHandler): boolean;
}
interface PlayerNPC extends AbstractMapObject {
	getName(): string;
	getType(): MapObjectType;
	getJob(): number;
	getGender(): number;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	getHair(): number;
	getFace(): number;
	removePlayerNPC(m: Character): void;
	spawnPlayerNPC(m: number, channel: java.awt.Point, mapid: Character): boolean;
	spawnPlayerNPC(mapid: number, chr: Character): boolean;
	getSkin(): number;
	getRX1(): number;
	getOverallJobRank(): number;
	getWorldRank(): number;
	getFH(): number;
	getWorldJobRank(): number;
	getDirection(): number;
	getEquips(): java.util.Map;
	getCY(): number;
	removeAllPlayerNPC(): void;
	getRX0(): number;
	getOverallRank(): number;
	getScriptId(): number;
	canSpawnPlayerNpc(rs: string, ps: number): boolean;
	updatePlayerNPCPosition(con: MapleMap, e: java.awt.Point): void;
	multicastSpawnPlayerNPC(mc: number, mapid: number): void;
}
interface World {
	shutdown(): void;
	find(id: number): number;
	find(name: string): number;
	getId(): number;
	getChannel(): Channel;
	getFamily(id: number): Family;
	registerDisabledServerMessage(): boolean;
	getCharacterPartyid(chrid: number): number;
	removePlayerHpDecrease(chr: Character): void;
	getPartySearchCoordinator(): PartySearchCoordinator;
	silentJoinMessenger(messengerid: number, target: MessengerCharacter, position: number): void;
	sendPacket(): void;
	broadcastPacket(): void;
	getExpRate(): number;
	getParty(partyid: number): Party;
	updateParty(oldLeaderMapid: number, eim: PartyOperation, mc: PartyCharacter): void;
	getMessenger(messengerid: number): Messenger;
	getGuild(mgc: GuildCharacter): Guild;
	removePlayer(): void;
	leaveMessenger(messengerid: number, target: MessengerCharacter): void;
	loggedOff(name: string, characterId: number, channel: number, buddies: number[]): void;
	getPlayerStorage(): PlayerStorage;
	getFlag(): number;
	setFlag(b: number): void;
	dropMessage(): void;
	getPlayerShop(ownerid: number): PlayerShop;
	getHiredMerchant(ownerid: number): HiredMerchant;
	addPlayer(chr: Character): void;
	updateMessenger(messengerid: number, namefrom: string, fromchannel: number): void;
	updateMessenger(): void;
	buddyChanged(): void;
	getMesoRate(): number;
	getQuestRate(): number;
	getDropRate(): number;
	getBossDropRate(): number;
	getRelationshipId(): number;
	unregisterMountHunger(chr: Character): void;
	registerFisherPlayer(chr: Character, baitLevel: number): boolean;
	unregisterPlayerShop(ps: PlayerShop): void;
	unregisterDisabledServerMessage(chrid: number): boolean;
	unregisterFisherPlayer(chr: Character): number;
	unregisterPetHunger(chr: Character, petSlot: number): void;
	registerTimedMapObject(): void;
	registerMountHunger(initProc: Character): void;
	getAccountStorage(accountId: number): Storage;
	loadAccountStorage(accountId: number): void;
	getServiceAccess(sv: WorldServices): BaseService;
	putGuildQueued(guildId: number): void;
	removeGuildQueued(guildId: number): void;
	isGuildQueued(guildId: number): boolean;
	putMarriageQueued(marriageId: number, cathedral: boolean, premium: boolean, groomId: number, brideId: number): void;
	isMarriageQueued(marriageId: number): boolean;
	canUninstall(): boolean;
	broadcastGMPacket(): void;
	multiBuddyFind(): CharacterIdChannelPair[];
	setServerMessage(): void;
	getChannels(): null[];
	getChannelsSize(): number;
	setGuildAndRank(): void;
	updateGuildSummary(gid: number, mgs: GuildSummary): void;
	joinMessenger(messengerid: number, target: MessengerCharacter, from: string, fromchannel: number): void;
	messengerChat(): void;
	addMessengerPlayer(): void;
	messengerInvite(): void;
	getActiveMerchants(): null[];
	setMesoRate(chr: number): void;
	setBossDropRate(bossdrop: number): void;
	setTravelRate(travel: number): void;
	addChannel(channel: Channel): boolean;
	setFishingRate(quest: number): void;
	getEventMessage(): string;
	setQuestRate(quest: number): void;
	setDropRate(chr: number): void;
	setExpRate(chr: number): void;
	getTravelRate(): number;
	getFishingRate(): number;
	removeChannel(): number;
	removeFamily(id: number): void;
	getFamilies(): null[];
	getGuildSummary(): GuildSummary;
	changeEmblem(gid: number, affectedPlayers: null[], mgs: GuildSummary): void;
	addMarriageGuest(marriageId: number, playerId: number): boolean;
	reloadGuildSummary(): void;
	addFamily(id: number, f: Family): void;
	createParty(chrfor: PartyCharacter): Party;
	declineChat(): void;
	buddyChat(): void;
	loggedOn(name: string, characterId: number, channel: number, buddies: number[]): void;
	partyChat(): void;
	createMessenger(chrfor: MessengerCharacter): Messenger;
	requestBuddyAdd(): BuddyAddResult;
	registerPlayerShop(ps: PlayerShop): void;
	registerPetHunger(): void;
	runMountSchedule(): void;
	runPetSchedule(): void;
	addOwlItemSearch(): void;
	addCashItemBought(cur: number): void;
	createRelationship(groomId: number, brideId: number): number;
	deleteRelationship(playerId: number, partnerId: number): void;
	getGmEvent(): GMEvent;
	setGmEvent(gmEvent: GMEvent): void;
	getTransportationTime(travelTime: number): number;
	getMarriageQueuedCouple(marriageId: number): Pair;
	resetDisabledServerMessages(): void;
	getWeddingCoupleForGuest(ch: number, loc: boolean): Pair;
	debugMarriageStatus(): void;
	getRelationshipCouple(): Pair;
	removeMarriageQueued(marriageId: number): Pair;
	getWorldCapacityStatus(): number;
	getMarriageQueuedLocation(marriageId: number): Pair;
	getAllCharactersView(): null[];
	getActivePlayerShops(): null[];
	setPlayerNpcMapData(mapid: number, step: number, podium: number): void;
	removeMessengerPlayer(): void;
	runTimedMapObjectSchedule(): void;
	getPlayerNpcMapStep(): number;
	getAccountCharactersView(accChars: number): null[];
	silentLeaveMessenger(messengerid: number, target: MessengerCharacter): void;
	setOfflineGuildStatus(): void;
	runPartySearchUpdateSchedule(): void;
	runHiredMerchantSchedule(): void;
	runPlayerHpDecreaseSchedule(): void;
	getPlayerNpcMapPodiumData(): number;
	getAvailableItemBundles(itemBundles: number): null[];
	loadAndGetAllCharactersView(): null[];
	resetPlayerNpcMapData(): void;
	getOwlSearchedItems(): null[];
	runDisabledServerMessagesSchedule(): void;
	runCheckFishingSchedule(): void;
	unregisterAccountStorage(accountId: number): void;
	setPlayerNpcMapStep(mapid: number, step: number): void;
	registerHiredMerchant(initProc: HiredMerchant): void;
	clearAccountCharacterView(): void;
	getMostSellerCashItems(): null[];
	unregisterHiredMerchant(hm: HiredMerchant): void;
	getMatchCheckerCoordinator(): MatchCheckerCoordinator;
	setPlayerNpcMapPodiumData(mapid: number, podium: number): void;
	isWorldCapacityFull(): boolean;
	unregisterAccountCharacterView(accountId: number, chrId: number): void;
	addPlayerHpDecrease(chr: Character): void;
	loadAccountCharactersView(): void;
	registerAccountCharacterView(accountId: number, chr: Character): void;
	removeMapPartyMembers(mc: number): void;
	isConnected(charName: string): boolean;
}
interface WorldServices {
	SAVE_CHARACTER: WorldServices;
	values(): WorldServices[];
	valueOf(name: string): WorldServices;
	createService(): Service;
	enumValues(): WorldServices[];
	enumValues(): java.lang.Enum[];
}
interface Storage {
	store(): boolean;
	close(): void;
	getSlot(ret: InventoryType, storageItems: number): number;
	getItem(slot: number): Item;
	getMeso(): number;
	getItems(): null[];
	gainSlots(slots: number): boolean;
	getSlots(): number;
	saveToDB(item: java.sql.Connection): void;
	canGainSlots(slots: number): boolean;
	loadOrCreateFromDB(item: number, ret: number): Storage;
	isFull(): boolean;
	resetStorage(): void;
	setMeso(meso: number): void;
	takeOut(type: Item): boolean;
	getStoreFee(): number;
	arrangeItems(msi: Client): void;
	sendMeso(c: Client): void;
	sendStorage(): void;
	sendStored(c: Client, type: InventoryType): void;
	sendTakenOut(c: Client, type: InventoryType): void;
	getTakeOutFee(): number;
	getCurrentNpcId(): number;
}
interface Event {
	getMapId(): number;
	getLimit(): number;
	minusLimit(): void;
	addLimit(): void;
}
interface PlayerStorage {
	getSize(): number;
	getCharacterById(id: number): Character;
	removePlayer(): Character;
	getAllCharacters(): null[];
	addPlayer(chr: Character): void;
	getCharacterByName(name: string): Character;
	disconnectAll(): void;
}
interface MatchCheckerCoordinator {
	createMatchConfirmation(): boolean;
	answerMatchConfirmation(): boolean;
	isMatchConfirmationActive(cid: number): boolean;
	dismissMatchConfirmation(): boolean;
	getMatchConfirmationLeaderid(cid: number): number;
	getMatchConfirmationType(cid: number): MatchCheckerType;
}
interface CharacterIdChannelPair {
	getChannel(): number;
	getCharacterId(): number;
}
interface EventManager {
	getName(): string;
	setName(name: string): void;
	getProperty(key: string): string;
	newInstance(name: string): EventInstanceManager;
	getInstance(name: string): EventInstanceManager;
	setProperty(key: string, value: string): void;
	setProperty(key: string, value: number): void;
	cancel(): void;
	getIntProperty(key: string): number;
	getChannelServer(): Channel;
	getWorldServer(): World;
	schedule(methodName: string, eim: EventInstanceManager, delay: number): EventScheduledFuture;
	schedule(methodName: string, delay: number): EventScheduledFuture;
	completeQuest(): void;
	startQuest(): void;
	getMonster(mid: number): Monster;
	getInstances(): null[];
	startInstance(lobbyId: number, party: Party, map: MapleMap, difficulty: number): boolean;
	startInstance(party: Party, map: MapleMap, difficulty: number): boolean;
	startInstance(message: number, e: Party, eim: MapleMap, ex: Character): boolean;
	startInstance(lobbyId: number, party: Party, map: MapleMap): boolean;
	startInstance(message: number, e: Character, eim: Character, ex: number): boolean;
	startInstance(party: Party, map: MapleMap): boolean;
	createInstance(name: string, ...args: any[]): EventInstanceManager;
	startInstance(): boolean;
	startInstance(lobbyId: number, eim: EventInstanceManager, ldr: string): boolean;
	startInstance(eim: EventInstanceManager, ldr: Character): boolean;
	startInstance(eim: EventInstanceManager, ldr: string): boolean;
	startInstance(chr: Character): boolean;
	startInstance(message: number, e: Party, eim: MapleMap, ex: number, ie: Character): boolean;
	startInstance(exped: Expedition): boolean;
	startInstance(lobbyId: number, exped: Expedition): boolean;
	startInstance(message: number, e: Expedition, eim: Character): boolean;
	startInstance(lobbyId: number, leader: Character): boolean;
	isQueueFull(): boolean;
	clearPQ(): void;
	getEligibleParty(partyChrs: Party): null[];
	getLobbyDelay(): number;
	setIntProperty(key: string, value: number): void;
	newMarriage(name: string): Marriage;
	disposeInstance(name: string): void;
	getIv(): javax.script.Invocable;
	getQueueSize(): number;
	addGuildToQueue(): number;
	attemptStartGuildInstance(): boolean;
	getTransportationTime(travelTime: number): number;
	scheduleAtTimestamp(methodName: string, timestamp: number): EventScheduledFuture;
	logMessage(scriptName: string, message: string): void;
	startTotemInstance(chr: Character, mapId: number): boolean;
}
interface MatchCheckerType {
	GUILD_CREATION: MatchCheckerType;
	CPQ_CHALLENGE: MatchCheckerType;
	values(): MatchCheckerType[];
	valueOf(name: string): MatchCheckerType;
	getListener(): AbstractMatchCheckerListener;
}
interface PartySearchCoordinator {
	attachPlayer(chr: Character): void;
	detachPlayer(chr: Character): void;
	unregisterPartyLeader(leader: Character): void;
	isInVicinity(callerRange: number, callerMapid: number): boolean;
	runPartySearch(): void;
	updatePartySearchStorage(): void;
	registerPartyLeader(leader: Character, minLevel: number, maxLevel: number, jobs: number): void;
}
interface LeaderSearchMetadata {
}
interface PartyCharacter {
	getName(): string;
	equals(obj: object): boolean;
	hashCode(): number;
	getId(): number;
	getChannel(): number;
	getLevel(): number;
	getJob(): Job;
	getPlayer(): Character;
	getMapId(): number;
	isOnline(): boolean;
	setOnline(online: boolean): void;
	getWorld(): number;
	setMapId(mapid: number): void;
	getGuildId(): number;
	setChannel(channel: number): void;
	isLeader(): boolean;
	getJobId(): number;
}
interface Job {
	BEGINNER: Job;
	WARRIOR: Job;
	FIGHTER: Job;
	CRUSADER: Job;
	HERO: Job;
	PAGE: Job;
	WHITEKNIGHT: Job;
	PALADIN: Job;
	SPEARMAN: Job;
	DRAGONKNIGHT: Job;
	DARKKNIGHT: Job;
	MAGICIAN: Job;
	FP_WIZARD: Job;
	FP_MAGE: Job;
	FP_ARCHMAGE: Job;
	IL_WIZARD: Job;
	IL_MAGE: Job;
	IL_ARCHMAGE: Job;
	CLERIC: Job;
	PRIEST: Job;
	BISHOP: Job;
	BOWMAN: Job;
	HUNTER: Job;
	RANGER: Job;
	BOWMASTER: Job;
	CROSSBOWMAN: Job;
	SNIPER: Job;
	MARKSMAN: Job;
	THIEF: Job;
	ASSASSIN: Job;
	HERMIT: Job;
	NIGHTLORD: Job;
	BANDIT: Job;
	CHIEFBANDIT: Job;
	SHADOWER: Job;
	PIRATE: Job;
	BRAWLER: Job;
	MARAUDER: Job;
	BUCCANEER: Job;
	GUNSLINGER: Job;
	OUTLAW: Job;
	CORSAIR: Job;
	MAPLELEAF_BRIGADIER: Job;
	GM: Job;
	SUPERGM: Job;
	NOBLESSE: Job;
	DAWNWARRIOR1: Job;
	DAWNWARRIOR2: Job;
	DAWNWARRIOR3: Job;
	DAWNWARRIOR4: Job;
	BLAZEWIZARD1: Job;
	BLAZEWIZARD2: Job;
	BLAZEWIZARD3: Job;
	BLAZEWIZARD4: Job;
	WINDARCHER1: Job;
	WINDARCHER2: Job;
	WINDARCHER3: Job;
	WINDARCHER4: Job;
	NIGHTWALKER1: Job;
	NIGHTWALKER2: Job;
	NIGHTWALKER3: Job;
	NIGHTWALKER4: Job;
	THUNDERBREAKER1: Job;
	THUNDERBREAKER2: Job;
	THUNDERBREAKER3: Job;
	THUNDERBREAKER4: Job;
	LEGEND: Job;
	EVAN: Job;
	ARAN1: Job;
	ARAN2: Job;
	ARAN3: Job;
	ARAN4: Job;
	EVAN1: Job;
	EVAN2: Job;
	EVAN3: Job;
	EVAN4: Job;
	EVAN5: Job;
	EVAN6: Job;
	EVAN7: Job;
	EVAN8: Job;
	EVAN9: Job;
	EVAN10: Job;
	values(): Job[];
	valueOf(name: string): Job;
	getId(): number;
	getMax(): number;
	isA(basejob: Job): boolean;
	getById(l: number): Job;
	getJobNiche(): number;
	getBy5ByteEncoding(encoded: number): Job;
}
interface PlayerShop extends AbstractMapObject {
	isOpen(): boolean;
	getType(): MapObjectType;
	broadcast(packet: Packet): void;
	getOwner(): Character;
	getChannel(): number;
	getMapId(): number;
	isBanned(name: string): boolean;
	getItemId(): number;
	isOwner(chr: Character): boolean;
	getItems(): null[];
	removeVisitor(j: Character): void;
	closeShop(): void;
	setOpen(openShop: boolean): void;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	addItem(item: PlayerShopItem): boolean;
	hasItem(): boolean;
	sendShop(c: Client): void;
	buy(price: Client, pItem: number, newItem: number): boolean;
	sendAvailableBundles(): null[];
	broadcastToVisitors(): void;
	broadcastRestoreToVisitors(): void;
	chat(c: Client, chat: string): void;
	visitShop(chr: Character): boolean;
	hasFreeSlot(): boolean;
	isVisitor(visitor: Character): boolean;
	takeItemBack(): void;
	banPlayer(): void;
	getVisitors(): Character[];
	removeVisitors(): void;
	forceRemoveVisitor(): void;
	getShopRoomInfo(): number[];
	setDescription(description: string): void;
	getDescription(): string;
	getSold(): null[];
}
interface PlayerShopItem {
	getItem(): Item;
	getPrice(): number;
	getBundles(): number;
	isExist(): boolean;
	setDoesExist(tf: boolean): void;
	setBundles(bundles: number): void;
}
interface Portal {
	TELEPORT_PORTAL: number;
	MAP_PORTAL: number;
	DOOR_PORTAL: number;
	OPEN: boolean;
	CLOSED: boolean;
	getName(): string;
	getId(): number;
	getType(): number;
	getTarget(): string;
	setPortalState(): void;
	getPortalState(): boolean;
	setScriptName(): void;
	getScriptName(): string;
	getPortalStatus(): boolean;
	enterPortal(): void;
	setPortalStatus(): void;
	getTargetMapId(): number;
	getPosition(): java.awt.Point;
}
interface SoldItem {
	getQuantity(): number;
	getItemId(): number;
	getBuyer(): string;
	getMesos(): number;
}
interface CharNameAndId {
	name: string;
	id: number;
}
interface Party {
	equals(obj: object): boolean;
	hashCode(): number;
	getId(): number;
	getMembers(): null[];
	getPartyMembersOnline(): null[];
	getMembersSortedByHistory(): null[];
	getLeader(): PartyCharacter;
	leaveParty(mcpq: Party, eim: Client): void;
	setEnemy(enemy: Party): void;
	getEnemy(): Party;
	getDoors(): java.util.Map;
	removeDoor(owner: number): void;
	addDoor(owner: number, door: Door): void;
	getMemberById(): PartyCharacter;
	getLeaderId(): number;
	assignNewLeader(): void;
	getPartyDoor(): number;
	setLeader(victim: PartyCharacter): void;
	getPartyMembers(): null[];
	getMemberByPos(): PartyCharacter;
	setEligibleMembers(eliParty: null[]): void;
	addMember(member: PartyCharacter): void;
	removeMember(member: PartyCharacter): void;
	updateMember(): void;
	createParty(partyplayer: Character, player: boolean): boolean;
	joinParty(partyplayer: Character, player: number, partyid: boolean): boolean;
	expelFromParty(partyMembers: Party, map: Client, mcpq: number): void;
	getEligibleMembers(): null[];
	containsMembers(member: PartyCharacter): boolean;
	setId(id: number): void;
}
interface Guild {
	getName(): string;
	equals(): boolean;
	hashCode(): number;
	getId(): number;
	getSignature(): number;
	getMembers(): null[];
	broadcast(packet: Packet, exception: number): void;
	broadcast(packet: Packet): void;
	broadcast(): void;
	setOnline(): void;
	getMGC(): GuildCharacter;
	dropMessage(message: string): void;
	dropMessage(): void;
	disbandGuild(): void;
	getAllianceId(): number;
	broadcastMessage(packet: Packet): void;
	getIncreaseGuildCost(size: number): number;
	memberLevelJobUpdate(): void;
	getLeaderId(): number;
	getCapacity(): number;
	guildMessage(mgc: Packet): void;
	getLogoBG(): number;
	getLogoColor(): number;
	getLogoBGColor(): number;
	getLogo(): number;
	getNotice(): string;
	displayGuildRanks(rs: Client, ps: number): void;
	increaseCapacity(): boolean;
	setAllianceId(con: number): void;
	getEligiblePlayersForGuild(chr: Character): java.util.Set;
	broadcastNameChanged(): void;
	broadcastEmblemChanged(): void;
	resetAllianceGuildPlayersRank(): void;
	broadcastInfoChanged(): void;
	guildChat(name: string, cid: number, message: string): void;
	leaveGuild(mgc: GuildCharacter): void;
	changeRank(): void;
	changeRankTitle(ranks: string[]): void;
	addGuildMember(): number;
	sendInvitation(c: Client, targetName: string): GuildResponse;
	answerInvitation(mgr: number, targetId: string, targetName: number, guildId: boolean): boolean;
	setGuildEmblem(bg: number, bgcolor: number, logo: number, logocolor: number): void;
	expelMember(con: GuildCharacter, e: string, re: number): void;
	setGuildNotice(notice: string): void;
	writeToDB(i: boolean): void;
	setLogo(l: number): void;
	createGuild(rs: number, ps: string): number;
	setLogoBG(bg: number): void;
	setLogoColor(c: number): void;
	removeGP(amount: number): void;
	getGP(): number;
	setLogoBGColor(c: number): void;
	setLeaderId(charId: number): number;
	gainGP(amount: number): void;
	getRankTitle(rank: number): string;
}
interface BCOp {
	NONE: BCOp;
	DISBAND: BCOp;
	EMBLEMCHANGE: BCOp;
	values(): BCOp[];
	valueOf(name: string): BCOp;
}
interface GuildResponse {
	NOT_IN_CHANNEL: GuildResponse;
	ALREADY_IN_GUILD: GuildResponse;
	NOT_IN_GUILD: GuildResponse;
	NOT_FOUND_INVITE: GuildResponse;
	MANAGING_INVITE: GuildResponse;
	DENIED_INVITE: GuildResponse;
	values(): GuildResponse[];
	valueOf(name: string): GuildResponse;
	getPacket(targetName: string): Packet;
}
interface Monster extends AbstractLoadedLife {
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	getName(): string;
	isAlive(): boolean;
	getType(): MapObjectType;
	getMap(): MapleMap;
	setMap(map: MapleMap): void;
	getLevel(): number;
	dispose(): void;
	aggroUpdateController(): void;
	aggroRedirectController(): void;
	getStats(): MonsterStats;
	getHp(): number;
	setMp(mp: number): void;
	getMp(): number;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	getSkills(): java.util.Set;
	getMaxHp(): number;
	getExp(): number;
	getMaxMp(): number;
	getTeam(): number;
	getCP(): number;
	dispelSkill(effects: MobSkill): void;
	heal(hp: number, mp: number): void;
	setTeam(team: number): void;
	isFacingLeft(): boolean;
	damage(attacker: Character, damage: number, stayAlive: boolean): boolean;
	isBoss(): boolean;
	applyMonsterBuff(): void;
	applyStatus(from: Character, status: MonsterStatusEffect, poison: boolean, duration: number): boolean;
	applyStatus(effectiveness: Character, service: MonsterStatusEffect, oldEffect: boolean, stat: number, poisonLevel: boolean): boolean;
	debuffMob(i: number): void;
	dropsDisabled(): boolean;
	getAnimationTime(name: string): number;
	lockMonster(): void;
	unlockMonster(): void;
	hasBossHPBar(): boolean;
	getStati(ms: MonsterStatus): MonsterStatusEffect;
	getStati(): java.util.Map;
	broadcastMobHpBar(mpc: Character): void;
	aggroClearDamages(): void;
	isMobile(): boolean;
	getController(): Character;
	resetMobPosition(newPoint: java.awt.Point): void;
	isBuffed(status: MonsterStatus): boolean;
	getVenomMulti(): number;
	isFake(): boolean;
	hasSkill(skillId: number, level: number): boolean;
	changeLevel(newLevel: number, pqMob: boolean): void;
	changeLevel(newLevel: number): void;
	setBoss(boss: boolean): void;
	isFirstAttack(): boolean;
	getBuffToGive(): number;
	getPADamage(): number;
	setVenomMulti(multiplier: number): void;
	setParentMobOid(parentMobId: number): void;
	disableDrops(): void;
	setHpZero(): void;
	applyFakeDamage(from: Character, damage: number, stayAlive: boolean): void;
	addHp(hp: number): void;
	setSpawnEffect(effect: number): void;
	setStartingHp(hp: number): void;
	disposeMapObject(): void;
	getSpawnEffect(): number;
	addSummonedMob(mob: Monster): void;
	enableDrops(): void;
	getParentMobOid(): number;
	isAttackedBy(chr: Character): boolean;
	killBy(reviveMap: Character): Character;
	canUseAttack(): number;
	setFake(fake: boolean): void;
	refreshMobPosition(): void;
	addListener(listener: MonsterListener): void;
	canUseSkill(): boolean;
	setOverrideStats(ostats: OverrideMonsterStats): void;
	getRandomSkill(): MobSkillId;
	getBanish(): BanishInfo;
	aggroAddPuppet(player: Character): void;
	getChangedStats(): ChangeableStats;
	alreadyBuffedStats(): null[];
	getDropPeriodTime(): number;
	changeDifficulty(difficulty: number, pqMob: boolean): void;
	hasAnySkill(): boolean;
	getMobMaxHp(): number;
	getStolen(): null[];
	addStolen(itemId: number): void;
	aggroResetAggro(): void;
	aggroMonsterDamage(attacker: Character, damage: number): void;
	aggroRemovePuppet(player: Character): void;
	getRemoveAfter(): number;
	applyAndGetHpDamage(trueHeal: number, hp2Heal: boolean): number;
	isCharacterPuppetInVicinity(): boolean;
	retrieveRelevantDrops(): null[];
	getHighestDamagerId(): number;
	aggroRemoveController(): Pair;
	makeBossHPBarPacket(): Packet;
	setTempEffectiveness(r: Element, service: ElementalEffectiveness, fE: number): void;
	aggroSwitchController(): void;
	countAvailableMobSummons(): number;
	popRemoveAfterAction(): java.lang.Runnable;
	isControllerKnowsAboutAggro(): boolean;
	pushRemoveAfterAction(run: java.lang.Runnable): void;
	isLeadingPuppetInVicinity(): boolean;
	getMapAggroCoordinator(): MonsterAggroCoordinator;
	isControllerHasAggro(): boolean;
	aggroUpdatePuppetVisibility(): void;
	dropFromFriendlyMonster(delay: number): void;
	getElementalEffectiveness(e: Element): ElementalEffectiveness;
	aggroMoveLifeUpdate(): boolean;
	aggroAutoAggroUpdate(player: Character): void;
	dispatchMonsterKilled(hasKiller: boolean): void;
}
interface ElementalEffectiveness {
	NORMAL: ElementalEffectiveness;
	IMMUNE: ElementalEffectiveness;
	STRONG: ElementalEffectiveness;
	WEAK: ElementalEffectiveness;
	NEUTRAL: ElementalEffectiveness;
	values(): ElementalEffectiveness[];
	valueOf(name: string): ElementalEffectiveness;
	getByNumber(num: number): ElementalEffectiveness;
}
interface MonsterStatusEffect {
	setValue(status: MonsterStatus, newVal: number): number;
	getSkill(): Skill;
	getStati(): java.util.Map;
	getMobSkill(): MobSkill;
	removeActiveStatus(stat: MonsterStatus): void;
	isMonsterSkill(): boolean;
}
interface MobSkill {
	getId(): MobSkillId;
	getType(): MobSkillType;
	getDuration(): number;
	getX(): number;
	getY(): number;
	getCoolTime(): number;
	makeChanceResult(): boolean;
	getMpCon(): number;
	applyEffect(monster: Monster): void;
	applyEffect(player: Character, monster: Monster, skill: boolean, banishPlayersOutput: null[]): void;
	getHP(): number;
	applyDelayedEffect(player: Character, monster: Monster, skill: boolean, animationTime: number): void;
}
interface MobSkillType {
	ATTACK_UP: MobSkillType;
	MAGIC_ATTACK_UP: MobSkillType;
	DEFENSE_UP: MobSkillType;
	MAGIC_DEFENSE_UP: MobSkillType;
	UNKNOWN_105: MobSkillType;
	ATTACK_UP_M: MobSkillType;
	MAGIC_ATTACK_UP_M: MobSkillType;
	DEFENSE_UP_M: MobSkillType;
	MAGIC_DEFENSE_UP_M: MobSkillType;
	HEAL_M: MobSkillType;
	HASTE_M: MobSkillType;
	SEAL: MobSkillType;
	DARKNESS: MobSkillType;
	WEAKNESS: MobSkillType;
	STUN: MobSkillType;
	CURSE: MobSkillType;
	POISON: MobSkillType;
	SLOW: MobSkillType;
	DISPEL: MobSkillType;
	SEDUCE: MobSkillType;
	BANISH: MobSkillType;
	AREA_POISON: MobSkillType;
	REVERSE_INPUT: MobSkillType;
	UNDEAD: MobSkillType;
	STOP_POTION: MobSkillType;
	STOP_MOTION: MobSkillType;
	FEAR: MobSkillType;
	UNKNOWN_138: MobSkillType;
	PHYSICAL_IMMUNE: MobSkillType;
	MAGIC_IMMUNE: MobSkillType;
	HARD_SKIN: MobSkillType;
	PHYSICAL_COUNTER: MobSkillType;
	MAGIC_COUNTER: MobSkillType;
	PHYSICAL_AND_MAGIC_COUNTER: MobSkillType;
	UNKNOWN_146: MobSkillType;
	PAD: MobSkillType;
	MAD: MobSkillType;
	PDR: MobSkillType;
	MDR: MobSkillType;
	ACC: MobSkillType;
	EVA: MobSkillType;
	SPEED: MobSkillType;
	SEAL_SKILL: MobSkillType;
	UNKNOWN_170: MobSkillType;
	UNKNOWN_171: MobSkillType;
	UNKNOWN_172: MobSkillType;
	UNKNOWN_173: MobSkillType;
	UNKNOWN_174: MobSkillType;
	UNKNOWN_175: MobSkillType;
	UNKNOWN_176: MobSkillType;
	UNKNOWN_177: MobSkillType;
	UNKNOWN_179: MobSkillType;
	UNKNOWN_180: MobSkillType;
	UNKNOWN_181: MobSkillType;
	SUMMON: MobSkillType;
	UNKNOWN_201: MobSkillType;
	values(): MobSkillType[];
	valueOf(name: string): MobSkillType;
	from(id: number): java.util.Optional;
	getId(): number;
}
interface Element {
	NEUTRAL: Element;
	PHYSICAL: Element;
	FIRE: Element;
	ICE: Element;
	LIGHTING: Element;
	POISON: Element;
	HOLY: Element;
	DARKNESS: Element;
	values(): Element[];
	valueOf(name: string): Element;
	getValue(): number;
	getFromChar(c: string): Element;
	isSpecial(): boolean;
}
interface MobSkillId {
	type(): MobSkillType;
	equals(o: object): boolean;
	toString(): string;
	hashCode(): number;
	level(): number;
}
interface MonsterStatus {
	WATK: MonsterStatus;
	WDEF: MonsterStatus;
	NEUTRALISE: MonsterStatus;
	PHANTOM_IMPRINT: MonsterStatus;
	MATK: MonsterStatus;
	MDEF: MonsterStatus;
	ACC: MonsterStatus;
	AVOID: MonsterStatus;
	SPEED: MonsterStatus;
	STUN: MonsterStatus;
	FREEZE: MonsterStatus;
	POISON: MonsterStatus;
	SEAL: MonsterStatus;
	SHOWDOWN: MonsterStatus;
	WEAPON_ATTACK_UP: MonsterStatus;
	WEAPON_DEFENSE_UP: MonsterStatus;
	MAGIC_ATTACK_UP: MonsterStatus;
	MAGIC_DEFENSE_UP: MonsterStatus;
	DOOM: MonsterStatus;
	SHADOW_WEB: MonsterStatus;
	WEAPON_IMMUNITY: MonsterStatus;
	MAGIC_IMMUNITY: MonsterStatus;
	HARD_SKIN: MonsterStatus;
	NINJA_AMBUSH: MonsterStatus;
	ELEMENTAL_ATTRIBUTE: MonsterStatus;
	VENOMOUS_WEAPON: MonsterStatus;
	BLIND: MonsterStatus;
	SEAL_SKILL: MonsterStatus;
	INERTMOB: MonsterStatus;
	WEAPON_REFLECT: MonsterStatus;
	MAGIC_REFLECT: MonsterStatus;
	values(): MonsterStatus[];
	valueOf(name: string): MonsterStatus;
	getValue(): number;
	isFirst(): boolean;
}
interface OxQuiz {
	sendQuestion(): void;
}
interface MatchCheckingEntry {
}
interface OverrideMonsterStats {
	hp: number;
	exp: number;
	mp: number;
	getHp(): number;
	getMp(): number;
	getExp(): number;
	setOHp(hp: number): void;
	setOMp(mp: number): void;
	setOExp(exp: number): void;
}
interface EventInstanceManager {
	getName(): string;
	getProperty(key: string): string;
	setProperty(key: string, value: number): void;
	setProperty(key: string, value: string): void;
	setProperty(key: string, value: string, prev: boolean): object;
	setName(name: string): void;
	dispose(): void;
	dispose(chr: boolean): void;
	getIntProperty(key: string): number;
	playerDisconnected(): void;
	getLeader(): Character;
	removePlayer(): void;
	schedule(): void;
	dropMessage(): void;
	changedMap(chr: Character, mapId: number): void;
	getPlayerCount(): number;
	registerPlayer(): void;
	registerPlayer(chr: Character): void;
	movePlayer(): void;
	afterChangedMap(chr: Character, mapId: number): void;
	getMapInstance(mapId: number): MapleMap;
	exitPlayer(): void;
	recoverOpenedGate(chr: Character, thisMapId: number): void;
	getMapFactory(): MapManager;
	getLeaderId(): number;
	unregisterPlayer(): void;
	playerKilled(chr: Character): void;
	setLeader(chr: Character): void;
	isLeader(chr: Character): boolean;
	startEventTimer(): void;
	gridRemove(chr: Character): void;
	stopEventTimer(): void;
	getClearStageMeso(stage: number): number;
	showClearEffect(hasGate: boolean): void;
	showClearEffect(hasGate: boolean, mapId: number): void;
	showClearEffect(mapId: number): void;
	showClearEffect(): void;
	showClearEffect(mapId: number, mapObj: string, newState: number): void;
	showClearEffect(hasGate: boolean, mapId: number, mapObj: string, newState: number): void;
	giveEventReward(player: Character): boolean;
	giveEventReward(rewardsQty: Character, rewardExp: number): boolean;
	getInstanceMap(mapid: number): MapleMap;
	getClearStageExp(stage: number): number;
	getClearStageBonus(stage: number): null[];
	showWrongEffect(mapId: number): void;
	showWrongEffect(): void;
	setEventRewards(eventLevel: number, rwds: null[], qtys: null[]): void;
	setEventRewards(eventLevel: number, rwds: null[], qtys: null[], expGiven: number): void;
	setEventRewards(rwds: null[], qtys: null[], expGiven: number): void;
	setEventRewards(rwds: null[], qtys: null[]): void;
	setObjectProperty(key: string, obj: object): void;
	isEventCleared(): boolean;
	getKillCount(chr: Character): number;
	addEventTimer(): void;
	isEventDisposed(): boolean;
	setEventCleared(): void;
	restartEventTimer(time: number): void;
	setExclusiveItems(items: null[]): void;
	getObjectProperty(key: string): object;
	linkToNextStage(thisStage: number, eventFamily: string, thisMapId: number): void;
	gridClear(): void;
	linkPortalToScript(thisStage: number, portalName: string, scriptName: string, thisMapId: number): void;
	gridCheck(): number;
	gridSize(): number;
	warpEventTeam(): void;
	getMonster(mid: number): Monster;
	spawnNpc(npcId: number, pos: java.awt.Point, map: MapleMap): void;
	isEventLeader(chr: Character): boolean;
	registerParty(chr: Character): void;
	registerParty(): void;
	getEm(): EventManager;
	startEvent(): void;
	clearPQ(): void;
	registerExpedition(exped: Expedition): void;
	setIntProperty(key: string, value: number): void;
	getTimeLeft(): number;
	disbandParty(): void;
	changedLeader(): void;
	getPlayerById(id: number): Character;
	monsterKilled(): void;
	monsterKilled(inc: Character, ex: Monster): void;
	friendlyKilled(mob: Monster, hasKiller: boolean): void;
	reviveMonster(mob: Monster): void;
	friendlyItemDrop(mob: Monster): void;
	revivePlayer(): boolean;
	dispatchRaiseQuestMobCount(evChr: number, eventMembers: number): void;
	getEventPlayersJobs(): number;
	setEventClearStageExp(gain: null[]): void;
	giveEventPlayersStageReward(thisStage: number): void;
	checkEventTeamLacking(leavingEventMap: boolean, minPlayers: number): boolean;
	isExpeditionTeamLackingNow(leavingEventMap: boolean, minPlayers: number, quitter: Character): boolean;
	applyEventPlayersItemBuff(): void;
	disposeIfPlayerBelow(): boolean;
	giveEventPlayersExp(): void;
	giveEventPlayersExp(gain: number): void;
	applyEventPlayersSkillBuff(): void;
	applyEventPlayersSkillBuff(skillId: number): void;
	setEventClearStageMeso(gain: null[]): void;
	isEventTeamLackingNow(leavingEventMap: boolean, minPlayers: number, quitter: Character): boolean;
	giveEventPlayersMeso(): void;
	giveEventPlayersMeso(gain: number): void;
	invokeScriptFunction(name: string, args: object[]): object;
	activatedAllReactorsOnMap(mapId: number, minReactorId: number, maxReactorId: number): boolean;
	activatedAllReactorsOnMap(): boolean;
	isEventTeamTogether(): boolean;
	warpEventTeamToMapSpawnPoint(): void;
	friendlyDamaged(mob: Monster): void;
	gridInsert(chr: Character, newStatus: number): void;
	leftParty(): void;
	registerMonster(mob: Monster): void;
	getPlayers(): Character[] | null;
	isTimerStarted(): boolean;
}
interface Door {
	getTarget(): MapleMap;
	isActive(): boolean;
	getElapsedDeployTime(): number;
	updateDoorPortal(owner: Character): void;
	getTownDoor(): DoorObject;
	attemptRemoveDoor(town: Character): void;
	getTownPortal(): Portal;
	getTown(): MapleMap;
	getDoorStatus(): Pair;
	getOwnerId(): number;
	getAreaDoor(): DoorObject;
}
interface Family {
	getName(): string;
	getMessage(): string;
	addEntry(entry: FamilyEntry): void;
	broadcast(packet: Packet): void;
	broadcast(): void;
	getID(): number;
	getLeader(): FamilyEntry;
	getWorld(): number;
	setLeader(leader: FamilyEntry): void;
	addEntryTree(): void;
	removeEntryBranch(): void;
	resetDailyReps(): void;
	saveAllMembersRep(): void;
	loadAllFamilies(rs: java.sql.Connection): void;
	getTotalMembers(): number;
	getEntryByID(cid: number): FamilyEntry;
	getTotalGenerations(): number;
	setTotalGenerations(generations: number): void;
	broadcastFamilyInfoUpdate(): void;
	setMessage(con: string, e: boolean): void;
}
interface InventoryType {
	UNDEFINED: InventoryType;
	EQUIP: InventoryType;
	USE: InventoryType;
	SETUP: InventoryType;
	ETC: InventoryType;
	CASH: InventoryType;
	CANHOLD: InventoryType;
	EQUIPPED: InventoryType;
	values(): InventoryType[];
	valueOf(name: string): InventoryType;
	getType(): number;
	getBitfieldEncoding(): number;
	getByType(l: number): InventoryType;
	getByWZName(name: string): InventoryType;
}
interface BaseService {
	dispose(): void;
}
interface EventScheduledFuture {
	cancel(dummy: boolean): void;
}
interface HiredMerchant extends AbstractMapObject {
	isOpen(): boolean;
	getType(): MapObjectType;
	getOwner(): string;
	getMap(): MapleMap;
	getChannel(): number;
	getMapId(): number;
	getItemId(): number;
	isOwner(chr: Character): boolean;
	forceClose(): void;
	getItems(): null[];
	saveItems(newBundle: boolean): void;
	removeVisitor(visitor: Character): void;
	setOpen(set: boolean): void;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	addItem(item: PlayerShopItem): boolean;
	getOwnerId(): number;
	hasItem(): boolean;
	buy(): void;
	sendAvailableBundles(): null[];
	removeFromBlacklist(chrName: string): void;
	broadcastToVisitorsThreadsafe(packet: Packet): void;
	clearInexistentItems(): void;
	getVisitorCharacters(): Character[];
	getVisitorSlotThreadsafe(visitor: Character): number;
	sendMessage(chr: Character, msg: string): void;
	visitShop(chr: Character): void;
	addVisitor(): boolean;
	closeOwnerMerchant(chr: Character): void;
	getBlacklist(): java.util.Set;
	withdrawMesos(chr: Character): void;
	addToBlacklist(chrName: string): void;
	takeItemBack(): void;
	isPublished(): boolean;
	getVisitorHistory(): null[];
	clearMessages(): void;
	getShopRoomInfo(): number[];
	clearItems(): void;
	setDescription(description: string): void;
	getDescription(): string;
	getMessages(): null[];
	getMesos(): number;
	getSold(): null[];
	getTimeOpen(): number;
}
interface server_maps_HiredMerchant$SoldItem {
	getQuantity(): number;
	getItemId(): number;
	getBuyer(): string;
	getMesos(): number;
}
interface PastVisitor {
	equals(o: object): boolean;
	toString(): string;
	hashCode(): number;
	chrName(): string;
	visitDuration(): java.time.Duration;
}
interface Visitor {
	equals(o: object): boolean;
	toString(): string;
	hashCode(): number;
	chr(): Character;
	enteredAt(): java.time.Instant;
}
interface SummonMovementType {
	STATIONARY: SummonMovementType;
	FOLLOW: SummonMovementType;
	CIRCLE_FOLLOW: SummonMovementType;
	values(): SummonMovementType[];
	valueOf(name: string): SummonMovementType;
	getValue(): number;
}
interface ScriptedItem {
	getValue(): object;
	setValue(value: object): void;
	getScript(): string;
	setScript(script: string): void;
	getNpc(): number;
	runOnPickup(): boolean;
}
interface DamageTask {
	run(): void;
}
interface EventManagerTask {
	run(): void;
}
interface SpawnCondition {
	canSpawn(): boolean;
}
interface GuildCharacter {
	getName(): string;
	equals(): boolean;
	hashCode(): number;
	getId(): number;
	getChannel(): number;
	getLevel(): number;
	setLevel(l: number): void;
	isOnline(): boolean;
	setOnline(f: boolean): void;
	setCharacter(ch: Character): void;
	getWorld(): number;
	getGuildId(): number;
	setChannel(ch: number): void;
	setJobId(job: number): void;
	getGuildRank(): number;
	getAllianceRank(): number;
	setGuildId(gid: number): void;
	setAllianceRank(rank: number): void;
	setGuildRank(rank: number): void;
	getJobId(): number;
	getCharacter(): Character;
	setOfflineGuildRank(rank: number): void;
}
interface NPC extends AbstractLoadedLife {
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	getName(): string;
	getType(): MapObjectType;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	sendShop(c: Client): void;
	hasShop(): boolean;
}
interface MonsterStats {
	changeable: boolean;
	exp: number;
	hp: number;
	mp: number;
	level: number;
	PADamage: number;
	PDDamage: number;
	MADamage: number;
	MDDamage: number;
	dropPeriod: number;
	cp: number;
	buffToGive: number;
	removeAfter: number;
	boss: boolean;
	undead: boolean;
	ffaLoot: boolean;
	isExplosiveReward: boolean;
	firstAttack: boolean;
	removeOnMiss: boolean;
	name: string;
	animationTimes: java.util.Map;
	resistance: java.util.Map;
	revives: null[];
	tagColor: number;
	tagBgColor: number;
	skills: java.util.Set;
	cool: Pair;
	banish: BanishInfo;
	loseItem: null[];
	selfDestruction: selfDestruction;
	fixedStance: number;
	friendly: boolean;
	damageDivider: number;
	getName(): string;
	setName(name: string): void;
	copy(): MonsterStats;
	getLevel(): number;
	setLevel(level: number): void;
	getHp(): number;
	setHp(hp: number): void;
	setMp(mp: number): void;
	getMp(): number;
	setExp(exp: number): void;
	getSkills(): java.util.Set;
	getExp(): number;
	getCP(): number;
	setCP(cp: number): void;
	isBoss(): boolean;
	setRemoveAfter(removeAfter: number): void;
	getRevives(): null[];
	getAnimationTime(name: string): number;
	getTagColor(): number;
	getTagBgColor(): number;
	isFriendly(): boolean;
	getEffectiveness(e: Element): ElementalEffectiveness;
	isMobile(): boolean;
	getFixedStance(): number;
	hasSkill(): boolean;
	getBanishInfo(): BanishInfo;
	isChangeable(): boolean;
	getNoSkills(): number;
	setEffectiveness(e: Element, ee: ElementalEffectiveness): void;
	setBoss(boss: boolean): void;
	getDropPeriod(): number;
	isFirstAttack(): boolean;
	getBuffToGive(): number;
	getPADamage(): number;
	getMADamage(): number;
	getMDDamage(): number;
	getPDDamage(): number;
	setChange(change: boolean): void;
	setExplosiveReward(isExplosiveReward: boolean): void;
	setRemoveOnMiss(removeOnMiss: boolean): void;
	setCool(cool: Pair): void;
	setUndead(undead: boolean): void;
	setFfaLoot(ffaLoot: boolean): void;
	setRevives(revives: null[]): void;
	setAnimationTime(name: string, delay: number): void;
	setSkills(skills: java.util.Set): void;
	setTagColor(tagColor: number): void;
	setFirstAttack(firstAttack: boolean): void;
	setBuffToGive(buff: number): void;
	setBanishInfo(banish: BanishInfo): void;
	setDropPeriod(dropPeriod: number): void;
	isUndead(): boolean;
	setTagBgColor(tagBgColor: number): void;
	setPADamage(PADamage: number): void;
	addLoseItem(li: loseItem): void;
	setSelfDestruction(sd: selfDestruction): void;
	setPDDamage(PDDamage: number): void;
	getCool(): Pair;
	setFixedStance(stance: number): void;
	setMDDamage(MDDamage: number): void;
	setFriendly(value: boolean): void;
	setDamageDivider(damageDivider: number): void;
	setMADamage(MADamage: number): void;
	getDamageDivider(): number;
	isFfaLoot(): boolean;
}
interface selfDestruction {
	getHp(): number;
	getAction(): number;
	setRemoveAfter(removeAfter: number): void;
	removeAfter(): number;
}
interface loseItem {
	getId(): number;
	getX(): number;
	getChance(): number;
}
interface GuardianSpawnPoint {
	setPosition(position: java.awt.Point): void;
	getTeam(): number;
	setTeam(team: number): void;
	isTaken(): boolean;
	setTaken(taken: boolean): void;
	getPosition(): java.awt.Point;
}
interface Reactor extends AbstractMapObject {
	getName(): string;
	isAlive(): boolean;
	setName(name: string): void;
	getId(): number;
	getState(): number;
	destroy(): boolean;
	getType(): MapObjectType;
	isActive(): boolean;
	getMap(): MapleMap;
	setMap(map: MapleMap): void;
	setState(state: number): void;
	getStats(): ReactorStats;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	inDelayedRespawn(): boolean;
	setShouldCollect(collect: boolean): void;
	delayedRespawn(): void;
	hitLockReactor(): void;
	hitUnlockReactor(): void;
	getShouldCollect(): boolean;
	setFacingDirection(facingDirection: number): void;
	getFacingDirection(): number;
	delayedHitReactor(c: Client, delay: number): void;
	setDelay(delay: number): void;
	forceHitReactor(newState: number): void;
	setEventState(substate: number): void;
	resetReactorActions(newState: number): void;
	forceDelayedRespawn(): boolean;
	cancelReactorTimeout(): void;
	isRecentHitFromAttack(): boolean;
	getReactorType(): number;
	hitReactor(nextState: boolean, isInEndState: number, b: number, reactorType: number, e: Client): void;
	hitReactor(c: Client): void;
	getGuardian(): GuardianSpawnPoint;
	unlockReactor(): void;
	lockReactor(): void;
	setAlive(alive: boolean): void;
	getEventState(): number;
	getReactItem(index: number): Pair;
	getArea(): java.awt.Rectangle;
	makeSpawnData(): Packet;
	setGuardian(guardian: GuardianSpawnPoint): void;
	makeDestroyData(): Packet;
	getDelay(): number;
}
interface ReactorStats {
	getType(state: number): number;
	getBR(): java.awt.Point;
	getStateSize(state: number): number;
	getActiveSkills(state: number, index: number): null[];
	getTimeout(state: number): number;
	getTimeoutState(state: number): number;
	getTL(): java.awt.Point;
	getNextState(state: number, index: number): number;
	setBR(br: java.awt.Point): void;
	addState(state: number, type: number, reactItem: Pair, nextState: number, timeOut: number, canTouch: number): void;
	addState(state: number, data: null[], timeOut: number): void;
	setTL(tl: java.awt.Point): void;
	getReactItem(state: number, index: number): Pair;
}
interface MapManager {
	getMap(): MapleMap;
	dispose(): void;
	resetMap(mapid: number): MapleMap;
	isMapLoaded(mapId: number): boolean;
	getMaps(): java.util.Map;
	updateMaps(): void;
	getDisposableMap(mapid: number): MapleMap;
}
interface InPacket {
	readInt(): number;
	skip(): void;
	available(): number;
	readBytes(): number[];
	readByte(): number;
	readShort(): number;
	readLong(): number;
	seek(): void;
	readString(): string;
	readPos(): java.awt.Point;
	getPosition(): number;
}
interface FieldCopyUtil {
}
interface MapObjectType {
	NPC: MapObjectType;
	MONSTER: MapObjectType;
	ITEM: MapObjectType;
	PLAYER: MapObjectType;
	DOOR: MapObjectType;
	SUMMON: MapObjectType;
	SHOP: MapObjectType;
	MINI_GAME: MapObjectType;
	MIST: MapObjectType;
	REACTOR: MapObjectType;
	HIRED_MERCHANT: MapObjectType;
	PLAYER_NPC: MapObjectType;
	DRAGON: MapObjectType;
	KITE: MapObjectType;
	POSITION: MapObjectType;
	values(): MapObjectType[];
	valueOf(name: string): MapObjectType;
}
interface ChangeableStats extends OverrideMonsterStats {
	watk: number;
	matk: number;
	wdef: number;
	mdef: number;
	level: number;
	hp: number;
	exp: number;
	mp: number;
}
interface Builder {
	count(count: number): Builder;
	x(x: number): Builder;
	limit(limit: number): Builder;
	rb(rb: java.awt.Point): Builder;
	prop(prop: number): Builder;
	y(y: number): Builder;
	lt(lt: java.awt.Point): Builder;
	build(): MobSkill;
	duration(duration: number): Builder;
	hp(hp: number): Builder;
	mpCon(mpCon: number): Builder;
	cooltime(cooltime: number): Builder;
	spawnEffect(spawnEffect: number): Builder;
	toSummon(toSummon: null[]): Builder;
}
interface Expedition {
	getProperty(key: string): string;
	start(): void;
	contains(player: Character): boolean;
	setProperty(key: string, value: string): void;
	getType(): ExpeditionType;
	getMembers(): java.util.Map;
	dispose(log: boolean): void;
	getLeader(): Character;
	removeChannelExpedition(ch: Channel): void;
	addChannelExpedition(ch: Channel): boolean;
	ban(): void;
	isLeader(player: Character): boolean;
	isLeader(playerid: number): boolean;
	beginRegistration(): void;
	addMember(player: Character): string;
	removeMember(chr: Character): boolean;
	getMinSize(): number;
	getActiveMembers(): null[];
	getMaxSize(): number;
	monsterKilled(): void;
	isExpeditionTeamTogether(): boolean;
	warpExpeditionTeamToMapSpawnPoint(): void;
	getMemberList(): null[];
	finishRegistration(): void;
	getStartTime(): number;
	getRecruitingMap(): MapleMap;
	addMemberInt(player: Character): number;
	isRegistering(): boolean;
	isInProgress(): boolean;
	getBossLogs(): null[];
	warpExpeditionTeam(): void;
}
interface ExpeditionBossLog {
	getBossLogRecordsForParty(id: ExpeditionType, characterId: java.util.UUID): null[];
	setExpeditionCompleted(c: Client, type: ExpeditionType, duration: number): void;
	setExpeditionCompleted(c: Client, type: ExpeditionType, duration: number, damageDealt: number, partyUUID: java.util.UUID): void;
	setExpeditionCompleted(id: number, type: ExpeditionType): void;
	setExpeditionCompleted(c: Client, type: ExpeditionType): void;
	setExpeditionCompleted(ps: number, con: ExpeditionType, e: number, id: number, type: java.util.UUID): void;
	setExpeditionCompleted(c: Client, type: ExpeditionType, duration: number, damageDealt: number): void;
	reachedBossRewardLimit(cid: number, type: ExpeditionType): boolean;
	countPlayerEntriesByHwid(): number;
	getPlayerEntryCount(rs: number, ps: BossLogEntry): number;
	getWeeklyBossEntries(cid: number, showZeros: boolean): java.util.Map;
	resetBossLogTable(): void;
	getBossEntries(e: number, boss: boolean, completed: boolean): java.util.Map;
	attemptBoss(cid: number, channel: number, exped: Expedition, log: boolean): boolean;
	insertPlayerEntry(ps: number, con: BossLogEntry): void;
	countPlayerEntries(rs: number, ps: BossLogEntry): number;
	removePlayerEntry(con: number, ps: BossLogEntry, e: number): void;
}
interface BossLogEntry {
	ZAKUM: BossLogEntry;
	HORNTAIL: BossLogEntry;
	PINKBEAN: BossLogEntry;
	SCARGA: BossLogEntry;
	PAPULATUS: BossLogEntry;
	VONLEON: BossLogEntry;
	CYGNUS: BossLogEntry;
	WILLSPIDER: BossLogEntry;
	VERUS: BossLogEntry;
	DARKNELL: BossLogEntry;
	KREXEL: BossLogEntry;
	CASTELLAN: BossLogEntry;
	LUCID: BossLogEntry;
	values(): BossLogEntry[];
	valueOf(name: string): BossLogEntry;
	getEntries(): number;
	getIndex(): number;
	getBossEntryByName(b: string): BossLogEntry;
	getOrdinal(): number;
	getIsWeekly(): boolean;
}
interface LeaderboardRecord {
	getRecords(): ExpeditionBossLogRecord[];
	getPartyUuid(): java.util.UUID;
	addRecord(record: ExpeditionBossLogRecord): void;
	getFormattedAttemptTime(): string;
	getFormattedCompletionTime(): string;
}
interface ExpeditionBossLogRecord {
	getId(): number;
	getDuration(): number;
	getPartyUuid(): java.util.UUID;
	isComplete(): boolean;
	getCharacterId(): number;
	getCharacterName(): string;
	getBossType(): string;
	getDamageDealt(): number;
	getAttemptTime(): java.sql.Timestamp;
	setPartyUuid(partyUuid: java.util.UUID): void;
	setComplete(complete: boolean): void;
	setAttemptTime(attemptTime: java.sql.Timestamp): void;
	setId(id: number): void;
	setBossType(bossType: string): void;
	setDamageDealt(damageDealt: number): void;
	setCharacterId(characterId: number): void;
	getCharacterName(characterName: string): void;
	setDuration(duration: number): void;
}
interface ExpeditionLeaderboard {
	updateLeaderboardFromExpedition(record: ExpeditionType, ps: java.util.UUID): void;
	getGlobalLeaderboardStringForBoss(boss: BossLogEntry): string;
	getPersonalLeaderboardStringForBoss(characterId: number, boss: BossLogEntry): string;
}

interface Kite extends AbstractMapObject {
	getType(): MapObjectType;
	getOwner(): Character;
	setPosition(position: java.awt.Point): void;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	makeSpawnData(): Packet;
	makeDestroyData(): Packet;
	getPosition(): java.awt.Point;
}
interface MatchCheckingElement {
}
interface Coconut extends Event {
	warpOut(): void;
	getAllCoconuts(): null[];
	bonusTime(): void;
	startEvent(): void;
	setCoconutsHittable(): void;
	getCoconut(id: number): Coconuts;
	getBombings(): number;
	addStoryScore(): void;
	fallCoconut(): void;
	getStoryScore(): number;
	stopCoconut(): void;
	addMapleScore(): void;
	getStopped(): number;
	getMapleScore(): number;
	bombCoconut(): void;
	getFalling(): number;
}
interface Coconuts {
	hit(): void;
	setHittable(hittable: boolean): void;
	resetHits(): void;
	getHitTime(): number;
	isHittable(): boolean;
	getHits(): number;
}
interface EventScriptManager extends AbstractScriptManager {
	init(): void;
	isActive(): boolean;
	reload(): void;
	cancel(): void;
	dispose(): void;
	getEventManager(event: string): EventManager;
}
interface AbstractScriptManager {
}
interface EventEntry {
	iv: javax.script.Invocable;
	em: EventManager;
}
interface Bingo {
	getMessage(): string;
	getHost(): Character;
	getMap(): MapleMap;
	getNumber(): number;
	setMap(map: MapleMap): void;
	process(str: Character, num: string): void;
	getMin(): number;
	getMax(): number;
	dropMessage(message: string): void;
	guess(num: number): number;
	setMin(min: number): void;
	setMax(max: number): void;
	getTurnIndex(): number;
	setTurnIndex(turnIndex: number): void;
	getParticipants(): null[];
	setNumber(number: number): void;
	currTurn(): Character;
	removeParticipant(name: string): void;
	removeParticipant(cid: number): void;
	addParticipant(chr: Character): void;
	setParticipants(participants: null[]): void;
	nextTurn(): void;
	randomNumber(): number;
	setHost(host: Character): void;
}
interface FamilyEntry {
	getName(): string;
	join(success: FamilyEntry): void;
	getFamily(): Family;
	fork(): void;
	getLevel(): number;
	getJob(): Job;
	setCharacter(newCharacter: Character): void;
	giveReputationToSenior(gain: number, includeSuperSenior: boolean): void;
	getChr(): Character;
	getSenior(): FamilyEntry;
	savedSuccessfully(): void;
	saveReputation(): boolean;
	saveReputation(e: java.sql.Connection): boolean;
	setTodaysRep(today: number): void;
	setRepsToSenior(reputation: number): void;
	setTotalReputation(totalReputation: number): void;
	getJuniors(): null[];
	setEntitlementUsed(id: number): void;
	getChrId(): number;
	setReputation(reputation: number): void;
	doFullCount(): void;
	announceToSenior(): void;
	updateSeniorFamilyInfo(): void;
	resetEntitlementUsages(): void;
	getEntitlementUsageCount(entitlement: FamilyEntitlement): number;
	useEntitlement(con: FamilyEntitlement): boolean;
	isJunior(entry: FamilyEntry): boolean;
	getReputation(): number;
	isEntitlementUsed(entitlement: FamilyEntitlement): boolean;
	gainReputation(gain: number, countTowardsTotal: boolean): void;
	refundEntitlement(con: FamilyEntitlement): boolean;
	getTotalSeniors(): number;
	getTotalReputation(): number;
	setTotalJuniors(totalJuniors: number): void;
	getTotalJuniors(): number;
	removeJunior(): boolean;
	addJunior(): boolean;
	setTotalSeniors(totalSeniors: number): void;
	getTodaysRep(): number;
	getRepsToSenior(): number;
	getOtherJunior(junior: FamilyEntry): FamilyEntry;
	getJuniorCount(): number;
	setSenior(senior: FamilyEntry, save: boolean): boolean;
}
interface FamilyEntitlement {
	FAMILY_REUINION: FamilyEntitlement;
	SUMMON_FAMILY: FamilyEntitlement;
	SELF_DROP_1_5: FamilyEntitlement;
	SELF_EXP_1_5: FamilyEntitlement;
	FAMILY_BONDING: FamilyEntitlement;
	SELF_DROP_2: FamilyEntitlement;
	SELF_EXP_2: FamilyEntitlement;
	SELF_DROP_2_30MIN: FamilyEntitlement;
	SELF_EXP_2_30MIN: FamilyEntitlement;
	PARTY_DROP_2_30MIN: FamilyEntitlement;
	PARTY_EXP_2_30MIN: FamilyEntitlement;
	getName(): string;
	values(): FamilyEntitlement[];
	valueOf(name: string): FamilyEntitlement;
	getRepCost(): number;
	getUsageLimit(): number;
	getDescription(): string;
}
interface Character extends AbstractCharacterObject {
	ArrowPlatterSchedule: java.util.concurrent.ScheduledFuture;
	ArrowPlatterSchedule1: java.util.concurrent.ScheduledFuture;
	ArrowPlatterSchedule2: java.util.concurrent.ScheduledFuture;
	ArrowPlatterSchedule3: java.util.concurrent.ScheduledFuture;
	potionCount: number;
	inExpedition: boolean;
	activeArrowPlates: number;
	arrowplatterrunning: boolean;
	arrowplatterrunning1: boolean;
	arrowplatterrunning2: boolean;
	arrowplatterrunning3: boolean;
	currsummonid: number;
	ariantColiseum: AriantColiseum;
	totalCP: number;
	availableCP: number;
	damageCheckinProgress: boolean;
	damageChecks: boolean;
	damageCheck: number;
	damageTestLength: number;
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	getName(): string;
	toString(): string;
	isHidden(): boolean;
	getDefault(selectedKey: Client): Character;
	empty(): void;
	message(m: string): void;
	setName(name: string): void;
	getId(): number;
	getType(): MapObjectType;
	getSlot(): number;
	block(): void;
	getLanguage(): number;
	getChannel(): Channel;
	getLevel(): number;
	setLevel(level: number): void;
	getFamily(): Family;
	setMap(PmapId: number): void;
	setLanguage(con: number): void;
	setAwayFromChannelWorld(): void;
	updatePartySearchAvailability(psearchAvailable: boolean): void;
	getMPC(): PartyCharacter;
	forceUpdateItem(item: Item): void;
	dispelSkill(): void;
	removePet(i: Pet, slot: boolean): void;
	startMapEffect(msg: string, itemId: number): void;
	startMapEffect(msg: string, itemId: number, duration: number): void;
	awardQuestPoint(): void;
	unequipPet(pet: Pet, shift_left: boolean): void;
	unequipPet(pet: Pet, shift_left: boolean, hunger: boolean): void;
	makeMapleReadable(): string;
	ban(ps: string, query: string, ps2: boolean): boolean;
	ban(con: string): void;
	isBanned(): boolean;
	updateAreaInfo(area: number, info: string): void;
	clearCpqTimer(): void;
	setFamilyEntry(entry: FamilyEntry): void;
	gotPartyQuestItem(partyquestchar: string): boolean;
	isMarried(): boolean;
	doNameChange(success: number, con: string, e: string, characterId: number): void;
	doNameChange(): boolean;
	getGuildRank(): number;
	executeRebornAs(job: Job): void;
	addReborns(): void;
	setReborns(con: number): void;
	changeJob(statup: Job): void;
	getTier6(): number;
	getTier9(): number;
	setCP(a: number): void;
	setTotalCP(a: number): void;
	getTier7(): number;
	getTier8(): number;
	getTotalCP(): number;
	getTier2(): number;
	getTier3(): number;
	getTier1(): number;
	getTier4(): number;
	getTier5(): number;
	getLinkedStats(): number;
	openNpcIn(npc: number, time: number): void;
	openNpcIn(npc: string, time: number): void;
	openNpcIn(npc: number, scriptname: string, time: number, dispose: boolean): void;
	getLastVisitedMapids(): null[];
	getAllActiveStatups(): null[];
	debugListAllBuffsCount(): void;
	cannotEnterCashShop(): boolean;
	updateActiveEffects(): void;
	changeRebirthJobCerezeth(tap: Job): void;
	decreaseBattleshipHp(cooldown: number): void;
	setDisconnectedFromChannelWorld(): void;
	toggleRecvPartySearchInvite(): boolean;
	calculateMaxBaseMagicDamage(maxbasedamage: number): number;
	stopControllingMonster(monster: Monster): void;
	isRecvPartySearchInviteEnabled(): boolean;
	calculateMinBaseDamage(secondarystat: number, mainstat: WeaponType): number;
	setMapTransitionComplete(): void;
	getNumControlledMonsters(): number;
	changeFaceExpression(emote: number): void;
	resetPartySearchInvite(fromLeaderid: number): void;
	getControlledMonsters(): null[];
	getCharacterFromDatabase(i: string): java.util.Map;
	changeQuickslotKeybinding(aQuickslotKeyMapped: number[]): void;
	partyOperationUpdate(mc: Party, partyMapItems: null[]): void;
	setSessionTransitionState(): void;
	getAriantRoomLeaderName(room: number): string;
	canRecoverLastBanish(): boolean;
	removeIncomingInvites(): void;
	hasDisabledPartySearchInvite(fromLeaderid: number): boolean;
	toggleBlockCashShop(): void;
	silentApplyDiseases(di: java.util.Map): void;
	setEnteredChannelWorld(): void;
	disablePartySearchInvite(fromLeaderid: number): void;
	getLastUsedCashItem(): number;
	getMarriageInstance(): Marriage;
	getMonsterBookCover(): number;
	exportExcludedItems(exclItems: Client): void;
	getNextEmptyPetIndex(): number;
	closePartySearchInteractions(): void;
	getFinishedDojoTutorial(): boolean;
	getPartyMembersOnline(): null[];
	broadcastAcquaintances(packet: Packet): void;
	broadcastAcquaintances(type: number, message: string): void;
	setBanishPlayerData(banishMap: number, banishSp: number, banishTime: number): void;
	unregisterChairBuff(): boolean;
	clearBanishPlayerData(): void;
	addVisibleMapObject(mo: MapObject): void;
	removeVisibleMapObject(mo: MapObject): void;
	getParty(): Party;
	getFriendshipRings(): null[];
	isLoggedin(): boolean;
	getWorldServer(): World;
	isAwayFromWorld(): boolean;
	getCrushRings(): null[];
	getRelationshipId(): number;
	getEventInstance(): EventInstanceManager;
	getMapId(): number;
	getMastery(): number;
	getTotalInt(): number;
	setClient(c: Client): void;
	sendPacket(packet: Packet): void;
	isGM(): boolean;
	getSummonsValues(): null[];
	Hide(hide: boolean): void;
	Hide(m: boolean, mo: boolean): void;
	buffExpireTask(): void;
	diseaseExpireTask(): void;
	skillCooldownTask(): void;
	getJob(): Job;
	setGMLevel(level: number): void;
	getJobStyle(opt: number): Job;
	getJobStyle(): Job;
	getInventory(type: InventoryType): Inventory;
	calculateMaxBaseDamage(weapMulti: number): number;
	calculateMaxBaseDamage(secondarystat: number, mainstat: WeaponType): number;
	cancelEffectFromBuffStat(): void;
	releaseControlledMonsters(): void;
	cancelBuffStats(bel: BuffStat): void;
	getBuffedValue(): number;
	getMonsterCarnival(): MonsterCarnival;
	changeMap(target: MapleMap, pos: java.awt.Point): void;
	changeMap(target: MapleMap, pto: Portal): void;
	changeMap(): void;
	changeMap(to: MapleMap): void;
	changeMap(to: MapleMap, portal: number): void;
	broadcastStance(newStance: number): void;
	broadcastStance(): void;
	createDragon(): void;
	getWarpMap(warpMap: number): MapleMap;
	cancelEffect(itemId: number): void;
	cancelEffect(): boolean;
	getIdByName(id: string): number;
	dropMessage(type: number, message: string): void;
	dropMessage(message: string): void;
	getPlayerDoor(): Door;
	getSkillLevel(skill: number): number;
	getSkillLevel(skill: Skill): number;
	sendDestroyData(client: Client): void;
	sendSpawnData(): void;
	changeSkillLevel(): void;
	getClient(): Client;
	silentPartyUpdate(): void;
	getObjectId(): number;
	getGuild(): Guild;
	isCygnus(): boolean;
	setMPC(mpc: PartyCharacter): void;
	gainSlots(type: number, slots: number): boolean;
	gainSlots(type: number, slots: number, update: boolean): boolean;
	pickupItem(mesosamm: MapObject, nxGain: number): void;
	pickupItem(ob: MapObject): void;
	getMonsterBook(): MonsterBook;
	dispelDebuffs(): void;
	getMeso(): number;
	gainMeso(gain: number): void;
	gainMeso(): void;
	gainMeso(gain: number, show: boolean): void;
	getCashShop(): CashShop;
	getItemEffect(): number;
	getPartyId(): number;
	getDoors(): null[];
	applyPartyDoor(): void;
	isLoggedinWorld(): boolean;
	removePartyDoor(): Door;
	visitMap(idx: MapleMap): void;
	clearSummons(): void;
	setMapId(mapid: number): void;
	multiplySpawn(monster: number): void;
	multiplySpawn(): void;
	showHint(msg: string): void;
	showHint(msg: string, length: number): void;
	getMessenger(): Messenger;
	notifyMapTransferToPartner(): void;
	closePlayerInteractions(): void;
	cancelArrowPlatterTask(): void;
	getPartyMembersOnSameMap(): null[];
	applyConsumeOnPickup(mse: number, mc: boolean): boolean;
	hasDisease(dis: Disease): boolean;
	hasActiveBuff(mbsvh: number): boolean;
	giveDebuff(): void;
	sitChair(itemId: number): void;
	getDiseasesSize(): number;
	getAllDiseases(): java.util.Map;
	dispelDebuff(): void;
	disbandGuild(): void;
	haveItem(itemid: number): boolean;
	addCooldown(skillId: number, startTime: number, length: number): void;
	needQuestItem(): boolean;
	removeCooldown(skillId: number): void;
	getBuddylist(): BuddyList;
	updateAriantScore(dropQty: number): void;
	updateAriantScore(): void;
	canHold(itemid: number, quantity: number): boolean;
	canHold(itemid: number): boolean;
	getQuest(qs: Quest): QuestStatus;
	getQuest(quest: number): QuestStatus;
	deleteBuddy(otherCid: number): void;
	getWorld(): number;
	getAbstractPlayerInteraction(): AbstractPlayerInteraction;
	announceBattleshipHp(): void;
	deleteWhereCharacterId(ps: java.sql.Connection, con: string, sql: number): void;
	genericGuildMessage(code: number): void;
	gmLevel(): number;
	closeNpcShop(): void;
	closeHiredMerchant(): void;
	resetPlayerAggro(): void;
	closePlayerShop(): void;
	closeMiniGame(forceClose: boolean): void;
	isPartyMember(chr: Character): boolean;
	isPartyMember(cid: number): boolean;
	closeTrade(): void;
	closeRPS(): void;
	getPlayerShop(): PlayerShop;
	setShop(shop: Shop): void;
	updateSingleStat(stat: Stat, newval: number): void;
	gainExp(gain: number): void;
	gainExp(gain: number, show: boolean, inChat: boolean): void;
	gainExp(gain: number, show: boolean, inChat: boolean, white: boolean): void;
	gainExp(gain: number, party: number, show: boolean, inChat: boolean, white: boolean): void;
	loseExp(loss: number, show: boolean, inChat: boolean): void;
	loseExp(loss: number, show: boolean, inChat: boolean, white: boolean): void;
	countItem(itemid: number): number;
	levelUp(dex: boolean): void;
	setExp(amount: number): void;
	getMaxLevel(): number;
	gainFame(delta: number): void;
	gainFame(): boolean;
	updateExpStat(newval: number): void;
	getAriantColiseum(): AriantColiseum;
	isRidingBattleship(): boolean;
	getMount(): Mount;
	checkBerserk(skilllevel: boolean): void;
	getPetIndex(): number;
	getGuildId(): number;
	setFamilyId(familyId: number): void;
	getBossDropRate(): number;
	getMesoRate(): number;
	hasNoviceExpRate(): boolean;
	getExpRate(): number;
	getCardRate(mseItem: number): number;
	isBeginnerJob(): boolean;
	getExcluded(): java.util.Map;
	getGender(): number;
	getDropRate(): number;
	getBuffEffect(): StatEffect;
	getReborns(): number;
	getAlliance(): Alliance;
	setTargetHpBarHash(mobHash: number): void;
	getMaxClassLevel(): number;
	setTargetHpBarTime(timeNow: number): void;
	isGmJob(): boolean;
	haveItemWithId(itemid: number, checkEquipped: boolean): boolean;
	hasBuffFromSourceid(sourceid: number): boolean;
	setMessengerPosition(position: number): void;
	closePlayerMessenger(): void;
	getMessengerPosition(): number;
	addPet(): void;
	autoban(reason: string): void;
	setHasSandboxItem(): void;
	addPlayerRing(ring: Ring): void;
	resetExcluded(): void;
	addExcluded(petId: number, x: number): void;
	getPet(index: number): Pet;
	setPlayerShop(playerShop: PlayerShop): void;
	setMessenger(messenger: Messenger): void;
	setHiredMerchant(merchant: HiredMerchant): void;
	getMiniGame(): MiniGame;
	getQuestStatus(): number;
	getHiredMerchant(): HiredMerchant;
	getItemQuantity(itemid: number, checkEquipped: boolean): number;
	getBuffedStarttime(): number;
	peekSavedLocation(type: string): number;
	clearSavedLocation(type: SavedLocationType): void;
	setBuffedValue(): void;
	hasMerchant(): boolean;
	getJobType(): number;
	getMedalText(): string;
	getRemainingSp(): number;
	getSkills(): java.util.Map;
	dispelBuffCoupons(): void;
	getActiveCoupons(): java.util.Set;
	leaveParty(): boolean;
	yellowMessage(m: string): void;
	setPlayerRates(): void;
	getFamilyEntry(): FamilyEntry;
	isPartyLeader(): boolean;
	getGachaExp(): number;
	getJobRankMove(): number;
	getAccountID(): number;
	addCrushRing(r: Ring): void;
	addMarriageRing(r: Ring): void;
	getSkinColor(): SkinColor;
	getFace(): number;
	getExp(): number;
	getFame(): number;
	addFriendshipRing(r: Ring): void;
	getHair(): number;
	getRankMove(): number;
	getJobRank(): number;
	getRank(): number;
	updateRemainingSp(remainingSp: number): void;
	revertLastPlayerRates(): void;
	getCleanItemQuantity(itemid: number, checkEquipped: boolean): number;
	increaseGuildCapacity(): void;
	commitExcludedItems(): void;
	announceUpdateQuest(questUpdateType: DelayedQuestUpdate, params: object[]): void;
	getInitialSpawnpoint(): number;
	setAutopotHpAlert(hpPortion: number): void;
	canGainSlots(type: number, slots: number): boolean;
	setMerchantMeso(con: number): void;
	getAutopotHpAlert(): number;
	getAutopotMpAlert(): number;
	fetchDoorSlot(): number;
	getMacros(): SkillMacro[];
	setRPS(rps: RockPaperScissor): void;
	getMerchantNetMeso(): number;
	getKeymap(): java.util.Map;
	setAutopotMpAlert(mpPortion: number): void;
	giveCoolDowns(): void;
	addTotemCooldown(npcId: number, startTime: number, length: number): void;
	questTimeLimit2(quest: Quest, expires: number): void;
	getCP(): number;
	raiseQuestMobCount(e: number): void;
	getTeam(): number;
	gainCP(gain: number): void;
	cancelAllBuffs(mbse: boolean): void;
	getStartedQuests(): null[];
	respawn(returnMap: number): void;
	respawn(eim: EventInstanceManager, returnMap: number): void;
	registerChairBuff(): boolean;
	getAllCooldowns(): null[];
	saveCharToDB(sps: boolean): void;
	saveCharToDB(): void;
	getSlots(type: number): number;
	getVipTrockSize(): number;
	sendPolice(greason: number, reason: string, duration: number): void;
	sendPolice(text: string): void;
	getTrockSize(): number;
	updatePartyMemberHP(): void;
	getAllTotemCooldowns(): null[];
	cancelSkillCooldownTask(): void;
	cancelBuffExpireTask(): void;
	cancelTotemCooldownTask(): void;
	sellAllItemsFromPosition(): number;
	cancelExpirationTask(): void;
	getJailExpirationTimeLeft(): number;
	mergeAllItemsFromPosition(): void;
	cancelDiseaseExpireTask(): void;
	setExpeditionCompleted(type: ExpeditionType): void;
	updateRebornTableCerezeth(): void;
	setUsedOreStorage(): void;
	haveWeddingRing(): boolean;
	isMale(): boolean;
	getLastHealed(): number;
	getQuestMesoRate(): number;
	getQuestExpRate(): number;
	getExcludedItems(): java.util.Set;
	getFamilyId(): number;
	getRawMesoRate(): number;
	getCouponDropRate(): number;
	setUsingOreStorage(isUsingOreStorage: boolean): void;
	getAccountIdByName(id: string): number;
	getNameById(name: number): string;
	setUsedStorage(): void;
	getRawDropRate(): number;
	haveItemEquipped(itemid: number): boolean;
	getUsingOreStorage(): boolean;
	getCouponMesoRate(): number;
	getCouponExpRate(): number;
	getRawExpRate(): number;
	addMesosTraded(gain: number): void;
	getPartnerId(): number;
	setNpcCooldown(d: number): void;
	getCS(): boolean;
	addDojoPointsByMap(mapid: number): number;
	addFame(famechange: number): void;
	setOwlSearch(id: number): void;
	getMarriageItemId(): number;
	setPartnerId(partnerid: number): void;
	setCS(cs: boolean): void;
	hasJustMarried(): boolean;
	getNpcCooldown(): number;
	getRingById(ring: number): Ring;
	setMarriageItemId(itemid: number): void;
	addSummon(id: number, summon: Summon): void;
	getOwlSearch(): number;
	setLastCombo(time: number): void;
	getLastCombo(): number;
	setLastMobCount(count: number): void;
	getCombo(): number;
	getLastMobCount(): number;
	toggleExpGain(): void;
	newClient(c: Client): void;
	setCombo(count: number): void;
	toggleHide(login: boolean): void;
	cancelMagicDoor(): void;
	canCreateChar(nameTest: string): boolean;
	setMasteries(skill: number): void;
	removeSandboxItems(): void;
	canDoor(): boolean;
	canGiveFame(from: Character): FameStatus;
	changeCI(type: number): void;
	changeKeybinding(key: number, keybinding: KeyBinding): void;
	getLastBanishData(): Pair;
	forceChangeMap(): void;
	changeMapBanish(): void;
	warpAhead(map: number): void;
	changePage(page: number): void;
	getOwnedMap(): MapleMap;
	isChangingMaps(): boolean;
	setOwnedMap(map: MapleMap): void;
	checkMessenger(): void;
	changeTab(tab: number): void;
	changeType(type: number): void;
	controlMonster(monster: Monster): void;
	decreaseReports(): void;
	deleteCharFromDB(rs: Character, ps: number): boolean;
	deleteGuild(ps: number): void;
	canHoldUniques(): boolean;
	announceDiseases(): void;
	collectDiseases(): void;
	dispel(): void;
	cancelAllDebuffs(): void;
	purgeDebuffs(): void;
	canHoldMeso(gain: number): boolean;
	equipChanged(): void;
	gainGachaExp(): void;
	addGachaExp(gain: number): void;
	enteredScript(script: string, mapid: number): void;
	doHurtHp(): void;
	totemCooldownTask(): void;
	expirationTask(): void;
	getAvailableBuffs(): java.util.Set;
	getBuffSource(): number;
	getAriantSlotsRoom(room: number): number;
	getAllBuffs(): null[];
	getBattleshipHp(): number;
	getAllianceRank(): number;
	debugListAllBuffs(): void;
	registerEffect(healInterval: StatEffect, buffEffect: number, buffInterval: number, beholder: boolean): void;
	getDojoEnergy(): number;
	getDojoStage(): number;
	getCurrentPage(): number;
	getChair(): number;
	getMainTownDoor(): Door;
	getChalkboard(): string;
	getCurrentType(): number;
	getCompletedQuests(): null[];
	getCurrentTab(): number;
	getEnergyBar(): number;
	getDojoPoints(): number;
	getCurrentCI(): number;
	setCpqTimer(timer: java.util.concurrent.ScheduledFuture): void;
	toggleWhiteChat(): void;
	registerNameChange(rs: string): boolean;
	setDragon(dragon: Dragon): void;
	getPartyQuest(): PartyQuest;
	getLoginTime(): number;
	setLoginTime(time: number): void;
	getEvents(): java.util.Map;
	getDragon(): Dragon;
	getLoggedInTime(): number;
	getPartyQuestItems(): string;
	logOff(): void;
	getWhiteChat(): boolean;
	setPartyQuest(pq: PartyQuest): void;
	getEquippedMAD(): number;
	getMGC(): GuildCharacter;
	getTotalWatk(): number;
	setMGC(mgc: GuildCharacter): void;
	getNoPets(): number;
	getTargetHpBarTime(): number;
	getTargetHpBarHash(): number;
	getMiniGamePoints(type: MiniGameResult, omok: boolean): number;
	getMerchantMeso(): number;
	getTotalStr(): number;
	getTotalDex(): number;
	getTotalLuk(): number;
	getMasterLevel(skill: Skill): number;
	getMasterLevel(skill: number): number;
	getMarriageRing(): Ring;
	getRPS(): RockPaperScissor;
	getMesosTraded(): number;
	setPlayerAggro(mobHash: number): void;
	getFh(): number;
	getTotalMagic(): number;
	getQuestNoAdd(quest: Quest): QuestStatus;
	getStatForBuff(): StatEffect;
	getStorage(): Storage;
	getShop(): Shop;
	getSearch(): string;
	getSavedLocation(type: string): number;
	setQuestAdd(): void;
	getOreStorage(): OreStorage;
	getPossibleReports(): number;
	getPets(): Pet[];
	getQuestRemove(quest: Quest): QuestStatus;
	getSkillExpiration(skill: Skill): number;
	getSkillExpiration(skill: number): number;
	getQuestNAdd(): QuestStatus;
	haveCleanItem(itemid: number): boolean;
	couldBuyback(): boolean;
	hasGivenFame(con: Character): void;
	getVanquisherKills(): number;
	hasEmptySlot(itemId: number): boolean;
	hasEmptySlot(invType: number): boolean;
	handleOrbconsume(): void;
	getSummonByKey(id: number): Summon;
	showBuybackInfo(): void;
	isBuffFrom(): boolean;
	getVanquisherStage(): number;
	isSummonsEmpty(): boolean;
	containsSummon(summon: Summon): boolean;
	getTrade(): Trade;
	hasEntered(script: string, mapId: number): boolean;
	hasEntered(): boolean;
	isSuperBeginner(): boolean;
	isGuildLeader(): boolean;
	getGiftLogCerezeth(rs: string): number;
	isMapObjectVisible(mo: MapObject): boolean;
	isAran(): boolean;
	leaveMap(): void;
	attemptCatchFish(baitLevel: number): boolean;
	loadCharFromDB(pet: number, ring: Client, equip: boolean): Character;
	setWorldRates(): void;
	resetPlayerRates(): void;
	setGiftLogCerezeth(con1: string): void;
	revertPlayerRates(): void;
	revertWorldRates(): void;
	updateCouponRates(): void;
	mount(id: number, skillid: number): Mount;
	resetStats(): void;
	resetEnteredScript(mapId: number): void;
	resetEnteredScript(): void;
	removeAriantRoom(room: number): void;
	saveGuildStatus(): void;
	resetBattleshipHp(): void;
	saveCooldowns(): void;
	saveLocationOnWarp(): void;
	saveLocation(type: string): void;
	insertNewChar(skEntry: CharacterFactoryRecipe): boolean;
	setBuddyCapacity(capacity: number): void;
	sendMacros(): void;
	setChalkboard(text: string): void;
	setDojoEnergy(x: number): void;
	sendQuickmap(): void;
	setBattleshipHp(battleshipHp: number): void;
	setDojoPoints(x: number): void;
	setDojoStage(x: number): void;
	sendKeymap(): void;
	setAriantSlotRoom(room: number, slot: number): void;
	setEnergyBar(set: number): void;
	setGender(gender: number): void;
	setFace(face: number): void;
	setFame(fame: number): void;
	setGuildRank(_rank: number): void;
	setAllianceRank(_rank: number): void;
	setHasMerchant(con: boolean): void;
	setFieldInstance(fieldInstance: FieldInstanceManager): void;
	setGuildId(_id: number): void;
	addMerchantMesos(con: number): void;
	setEventInstance(eventInstance: EventInstanceManager): void;
	setHair(hair: number): void;
	setGachaExp(amount: number): void;
	setGM(level: number): void;
	applyHpMpChange(nextMp: number, cannotApplyHp: number, cannotApplyMp: number): boolean;
	setMiniGamePoints(visitor: Character, winnerslot: number, omok: boolean): void;
	setLastHealed(time: number): void;
	setMiniGame(miniGame: MiniGame): void;
	setParty(p: Party): void;
	setItemEffect(itemEffect: number): void;
	setJob(job: Job): void;
	getDoorSlot(): number;
	setInventory(type: InventoryType, inv: Inventory): void;
	setSkinColor(skinColor: SkinColor): void;
	setSearch(find: string): void;
	setSlot(slotid: number): void;
	setVanquisherStage(x: number): void;
	skillIsCooling(skillId: number): boolean;
	totemIsCooling(npcId: number): boolean;
	silentGiveBuffs(mbsv: null[]): void;
	shiftPetsRight(): void;
	showDojoClock(): void;
	setWorld(world: number): void;
	unequipAllPets(): void;
	setVanquisherKills(x: number): void;
	setTrade(trade: Trade): void;
	updateMacros(position: number, updateMacro: SkillMacro): void;
	questTimeLimit(quest: Quest, seconds: number): void;
	getNewYearRecord(): NewYearCardRecord;
	addNewYearRecord(newyear: NewYearCardRecord): void;
	setQuestProgress(): void;
	updateQuestStatus(questid: QuestStatus): void;
	getLinkedLevel(): number;
	getNewYearRecords(): java.util.Set;
	getLinkedName(): string;
	setObjectId(id: number): void;
	deleteFromTrocks(map: number): void;
	containsAreaInfo(area: number, info: string): boolean;
	unblockPortal(scriptName: string): void;
	getAreaInfos(): java.util.Map;
	getTrockMaps(): null[];
	getVipTrockMaps(): null[];
	addTrockMap(): void;
	isTrockMap(id: number): boolean;
	addVipTrockMap(): void;
	isVipTrockMap(id: number): boolean;
	getAutobanManager(): AutobanManager;
	unequippedItem(equip: Equip): void;
	equippedItem(equip: Equip): void;
	portalDelay(): number;
	portalDelay(delay: number): void;
	increaseEquipExp(itemName: number): void;
	getAreaInfo(area: number): string;
	blockPortal(scriptName: string): void;
	getBlockedPortals(): null[];
	reloadQuestExpirations(): void;
	setMonsterBookCover(bookCover: number): void;
	getTotemCooldownTimeRemaining(): number;
	prepareArrowPlatter(): void;
	removeNewYearRecord(newyear: NewYearCardRecord): void;
	generateCharacterEntry(): Character;
	setPlayerExpRatesCerezeth(expRate: number): void;
	forfeitExpirableQuests(): void;
	prepareArrowPlatter1(): void;
	setAriantRoomLeader(room: number, charname: string): void;
	getVisibleMapObjects(): MapObject[];
	removeAllCooldownsExcept(): void;
	questExpirationTask(): void;
	receivePartyMemberHP(): void;
	removeTotemCooldown(npcId: number): void;
	getReceivedNewYearRecords(): java.util.Set;
	loadCharacterEntryFromDB(item: java.sql.ResultSet, inv: null[]): Character;
	setFinishedDojoTutorial(): void;
	withdrawMerchantMesos(): void;
	showUnderleveledInfo(mob: Monster): void;
	handleEnergyChargeGain(): void;
	prepareArrowPlatter2(): void;
	setLastUsedCashItem(time: number): void;
	sellAllItemsFromName(): number;
	runTirednessSchedule(): boolean;
	runFullnessSchedule(): void;
	prepareArrowPlatter3(): void;
	cancelQuestExpirationTask(): void;
	showMapOwnershipInfo(medalItem: Character): void;
	mergeAllItemsFromName(statEq: string): boolean;
	flushDelayedUpdateQuests(): void;
	isEquippedItemPouch(): boolean;
	removePartyQuestItem(letter: string): void;
	deleteFromVipTrocks(map: number): void;
	showAllEquipFeatures(): void;
	addJailExpirationTime(time: number): void;
	setPartyQuestItemObtained(partyquestchar: string): void;
	removeJailExpirationTime(): void;
	isEquippedMesoMagnet(): boolean;
	cancelPendingNameChange(): boolean;
	isEquippedPetItemIgnore(): boolean;
	broadcastMarriageMessage(): void;
	setLastCommandMessage(text: string): void;
	getAllRebornDataCerezeth(): string;
	getCharactersByHWID(): null[];
	getCharacterStatsCerezeth(): string;
	executeRebornAfterFirstCerezeth(): void;
	setLastSnowballAttack(time: number): void;
	getLastSnowballAttack(): number;
	applyLinkStatsBoost(): void;
	doPendingNameChange(): void;
	getLastCommandMessage(): string;
	checkWorldTransferEligibility(): string;
	checkWorldTransferEligibility(): number;
	getMonsterCarnivalParty(): MonsterCarnivalParty;
	registerWorldTransfer(rs: number): boolean;
	cancelPendingWorldTranfer(): boolean;
	setMonsterCarnivalParty(mcp: MonsterCarnivalParty): void;
	setTeam(team: number): void;
	getRewardPoints(): number;
	executeReborn(): void;
	getOla(): Ola;
	setOla(ola: Ola): void;
	sellAllPosLast(): number;
	executeRebornAsId(jobId: number): void;
	setRewardPoints(con: number): void;
	doWorldTransfer(): boolean;
	setFitness(fit: Fitness): void;
	getAriantPoints(): number;
	gainAriantPoints(points: number): void;
	gainFestivalPoints(gain: number): void;
	setAriantColiseum(ariantColiseum: AriantColiseum): void;
	getFitness(): Fitness;
	getFestivalPoints(): number;
	getAvailableCP(): number;
	resetCP(): void;
	setMonsterCarnival(monsterCarnival: MonsterCarnival): void;
	setChallenged(challenged: boolean): void;
	useCP(ammount: number): void;
	addCP(ammount: number): void;
	isChallenged(): boolean;
	getGiftLog(ps: string): number;
	logExists(ps: string): number;
	deleteLog(con: string): void;
	setFestivalPoints(pontos: number): void;
	setBossLog(con: string): void;
	getBossLog(ps: string): number;
	isChasing(): boolean;
	AddTier9(points: number): void;
	UpdateTier2(): void;
	ResetTiers(points: number): void;
	UpdateTier3(): void;
	UpdateTier6(): void;
	AddTier6(points: number): void;
	UpdateTier8(): void;
	AddTier1(points: number): void;
	AddTier4(points: number): void;
	AddTier7(points: number): void;
	AddTier2(points: number): void;
	AddTier8(points: number): void;
	UpdateTier9(): void;
	UpdateTier1(): void;
	AddTier3(points: number): void;
	setChasing(chasing: boolean): void;
	UpdateTier4(): void;
	UpdateTier5(): void;
	UpdateTier7(): void;
	AddTier5(points: number): void;
	logActivity(): void;
	setAutoLogin(): void;
	getDataSearch(): string;
	damageTimer(): void;
	reachedRewardLimit(type: ExpeditionType): boolean;
	setPhilID(id: number): void;
	setDataSearchType(dataSearchType: string): void;
	getDataSearchArr(): null[];
	setDataSearchArr(arr: null[]): void;
	getDataSearchType(): string;
	getPhilID(): number;
	setDataSearch(result: string): void;
}
interface Mount {
	empty(): void;
	getId(): number;
	isActive(): boolean;
	getLevel(): number;
	setLevel(newlevel: number): void;
	getItemId(): number;
	setExp(newexp: number): void;
	setActive(set: boolean): void;
	incrementAndGetTiredness(): number;
	getExp(): number;
	setTiredness(newtiredness: number): void;
	setItemId(newitemid: number): void;
	setSkillId(newskillid: number): void;
	getTiredness(): number;
	getSkillId(): number;
}
interface AriantColiseum {
	clearAriantRewardTier(chr: Character): void;
	getAriantRewardTier(chr: Character): number;
	distributeAriantPoints(): void;
	clearAriantScore(chr: Character): void;
	getAriantScore(chr: Character): number;
	playerDisconnected(chr: Character): void;
	updateAriantScore(chr: Character, points: number): void;
	addLostShards(quantity: number): void;
	leaveArena(chr: Character): void;
}
interface Alliance {
	getName(): string;
	getId(): number;
	getLeader(): GuildCharacter;
	dropMessage(): void;
	dropMessage(message: string): void;
	broadcastMessage(packet: Packet): void;
	getCapacity(): number;
	saveToDB(): void;
	setCapacity(newCapacity: number): void;
	disbandAlliance(ps: number): void;
	getNotice(): string;
	increaseCapacity(inc: number): void;
	createAlliance(mc: Party, g: string): Alliance;
	loadAlliance(ranks: number): Alliance;
	canBeUsedAllianceName(rs: string): boolean;
	updateAlliancePackets(chr: Character): void;
	removeGuildFromAlliance(allianceId: number, guildId: number, worldId: number): boolean;
	sendInvitation(victim: Client, c: string, targetGuildName: number): void;
	answerInvitation(msg: number, targetId: string, targetGuildName: number, allianceId: boolean): boolean;
	addGuild(gid: number): boolean;
	createAllianceOnDb(rs: null[], ps: string): Alliance;
	setRankTitle(ranks: string[]): void;
	getAllianceNotice(): string;
	setNotice(notice: string): void;
	removeGuild(): boolean;
	getGuilds(): null[];
	getRankTitle(rank: number): string;
}
interface MonsterCarnival {
	D: number;
	C: number;
	B: number;
	A: number;
	exit(): void;
	complete(): void;
	playerDisconnected(mpc: number): void;
	getEventMap(): MapleMap;
	getCP(team: number): number;
	setTotalCP(totalCP: number, team: number): void;
	setCP(CP: number, team: number): void;
	getTotalCP(team: number): number;
	getTimeLeft(): number;
	getRed(): Party;
	setRed(p1: Party): void;
	getBlue(): Party;
	getTimer(): java.util.concurrent.ScheduledFuture;
	getRedTotalCP(): number;
	getRoom(): number;
	getBlueCP(): number;
	getRedCP(): number;
	getEnemyLeader(team: number): Character;
	getLeader1(): Character;
	setLeader1(leader1: Character): void;
	setBlueCP(blueCP: number): void;
	setLeader2(leader2: Character): void;
	setRedTotalCP(redTotalCP: number): void;
	setRedCP(redCP: number): void;
	getLeader2(): Character;
	setBlue(p2: Party): void;
	getBlueTotalCP(): number;
	setBlueTotalCP(blueTotalCP: number): void;
	summonR(): void;
	canGuardianB(): boolean;
	summonB(): void;
	canSummonB(): boolean;
	canSummonR(): boolean;
	canGuardianR(): boolean;
	leftParty(charid: number): void;
	getTimeLeftSeconds(): number;
}
interface Trade {
	getItems(): null[];
	cancelTrade(chr: Character, result: TradeResult): void;
	getChr(): Character;
	addItem(): boolean;
	inviteTrade(c1: Character, c2: Character): void;
	startTrade(chr: Character): void;
	declineTrade(other: Character): void;
	getPartner(): Trade;
	isFullTrade(): boolean;
	chat(message: string): void;
	visitTrade(c1: Character, c2: Character): void;
	setMeso(meso: number): void;
	completeTrade(chr: Character): void;
	setPartner(partner: Trade): void;
	setFullTrade(fullTrade: boolean): void;
	getExchangeMesos(): number;
	getFee(meso: number): number;
}
interface Stat {
	SKIN: Stat;
	FACE: Stat;
	HAIR: Stat;
	LEVEL: Stat;
	JOB: Stat;
	STR: Stat;
	DEX: Stat;
	INT: Stat;
	LUK: Stat;
	HP: Stat;
	MAXHP: Stat;
	MP: Stat;
	MAXMP: Stat;
	AVAILABLEAP: Stat;
	AVAILABLESP: Stat;
	EXP: Stat;
	FAME: Stat;
	MESO: Stat;
	PET: Stat;
	GACHAEXP: Stat;
	values(): Stat[];
	valueOf(name: string): Stat;
	getValue(): number;
	getBy5ByteEncoding(encoded: number): Stat;
	getByString(stat: string): Stat;
	getByValue(stat: number): Stat;
}
interface CoolTimeValueHolder {
	timeLeft(): number;
	past(): boolean;
}
interface FameStatus {
	OK: FameStatus;
	NOT_TODAY: FameStatus;
	NOT_THIS_MONTH: FameStatus;
	values(): FameStatus[];
	valueOf(name: string): FameStatus;
}
interface MonsterCarnivalParty {
	getMembers(): null[];
	getLeader(): Character;
	getTeam(): number;
	getTotalCP(): number;
	summon(): void;
	addCP(player: Character, ammount: number): void;
	getAvailableCP(): number;
	useCP(player: Character, ammount: number): void;
	warpOut(): void;
	warp(): void;
	removeMember(chr: Character): void;
	allInMap(): boolean;
	canSummon(): boolean;
	isWinner(): boolean;
	displayMatchResult(): void;
	setWinner(status: boolean): void;
}
interface AbstractCharacterObject extends AbstractAnimatedMapObject {
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	getInt(): number;
	isAlive(): boolean;
	getMap(): MapleMap;
	setMap(map: MapleMap): void;
	getStr(): number;
	getDex(): number;
	getHp(): number;
	getLuk(): number;
	getMp(): number;
	getCurrentMaxHp(): number;
	addHP(delta: number): void;
	gainSp(chr: Character, deltaSp: number, skillbook: number, silent: boolean): void;
	gainAp(deltaAp: number, silent: boolean): void;
	assignStrDexIntLuk(deltaStr: number, deltaDex: number, deltaInt: number, deltaLuk: number): boolean;
	getRemainingAp(): number;
	getRemainingSps(): number[];
	getMaxHp(): number;
	getMaxMp(): number;
	getClientMaxMp(): number;
	addMPHP(hpDelta: number, mpDelta: number): void;
	updateHp(hp: number): void;
	getClientMaxHp(): number;
	updateHpMp(newhp: number, newmp: number): void;
	updateHpMp(x: number): void;
	getCurrentMaxMp(): number;
	updateMpMaxMp(mp: number, maxmp: number): void;
	updateMaxHp(maxhp: number): void;
	updateMp(mp: number): void;
	updateMaxMp(maxmp: number): void;
	updateHpMaxHp(hp: number, maxhp: number): void;
	getHpMpApUsed(): number;
	updateMaxHpMaxMp(maxhp: number, maxmp: number): void;
	safeAddHP(delta: number): number;
	healHpMp(): void;
	addMP(delta: number): void;
	changeRemainingAp(x: number, silent: boolean): void;
	updateStrDexIntLuk(x: number): void;
	assignLuk(x: number): boolean;
	assignHP(): boolean;
	addMaxHP(delta: number): void;
	assignMP(): boolean;
	addMaxMP(delta: number): void;
	assignStr(x: number): boolean;
	assignDex(x: number): boolean;
	assignInt(x: number): boolean;
}
interface BuffStat {
	MORPH: BuffStat;
	RECOVERY: BuffStat;
	MAPLE_WARRIOR: BuffStat;
	STANCE: BuffStat;
	SHARP_EYES: BuffStat;
	MANA_REFLECTION: BuffStat;
	SHADOW_CLAW: BuffStat;
	INFINITY: BuffStat;
	HOLY_SHIELD: BuffStat;
	HAMSTRING: BuffStat;
	BLIND: BuffStat;
	CONCENTRATE: BuffStat;
	PUPPET: BuffStat;
	ECHO_OF_HERO: BuffStat;
	MESO_UP_BY_ITEM: BuffStat;
	GHOST_MORPH: BuffStat;
	AURA: BuffStat;
	CONFUSE: BuffStat;
	COUPON_EXP1: BuffStat;
	COUPON_EXP2: BuffStat;
	COUPON_EXP3: BuffStat;
	COUPON_EXP4: BuffStat;
	COUPON_DRP1: BuffStat;
	COUPON_DRP2: BuffStat;
	COUPON_DRP3: BuffStat;
	ITEM_UP_BY_ITEM: BuffStat;
	RESPECT_PIMMUNE: BuffStat;
	RESPECT_MIMMUNE: BuffStat;
	DEFENSE_ATT: BuffStat;
	DEFENSE_STATE: BuffStat;
	HPREC: BuffStat;
	MPREC: BuffStat;
	BERSERK_FURY: BuffStat;
	DIVINE_BODY: BuffStat;
	SPARK: BuffStat;
	MAP_CHAIR: BuffStat;
	FINALATTACK: BuffStat;
	WATK: BuffStat;
	WDEF: BuffStat;
	MATK: BuffStat;
	MDEF: BuffStat;
	ACC: BuffStat;
	AVOID: BuffStat;
	HANDS: BuffStat;
	SPEED: BuffStat;
	JUMP: BuffStat;
	MAGIC_GUARD: BuffStat;
	DARKSIGHT: BuffStat;
	BOOSTER: BuffStat;
	POWERGUARD: BuffStat;
	HYPERBODYHP: BuffStat;
	HYPERBODYMP: BuffStat;
	INVINCIBLE: BuffStat;
	SOULARROW: BuffStat;
	STUN: BuffStat;
	POISON: BuffStat;
	SEAL: BuffStat;
	DARKNESS: BuffStat;
	COMBO: BuffStat;
	SUMMON: BuffStat;
	WK_CHARGE: BuffStat;
	DRAGONBLOOD: BuffStat;
	HOLY_SYMBOL: BuffStat;
	MESOUP: BuffStat;
	SHADOWPARTNER: BuffStat;
	PICKPOCKET: BuffStat;
	MESOGUARD: BuffStat;
	EXP_INCREASE: BuffStat;
	WEAKEN: BuffStat;
	MAP_PROTECTION: BuffStat;
	SLOW: BuffStat;
	ELEMENTAL_RESET: BuffStat;
	MAGIC_SHIELD: BuffStat;
	MAGIC_RESISTANCE: BuffStat;
	WIND_WALK: BuffStat;
	ARAN_COMBO: BuffStat;
	COMBO_DRAIN: BuffStat;
	COMBO_BARRIER: BuffStat;
	BODY_PRESSURE: BuffStat;
	SMART_KNOCKBACK: BuffStat;
	BERSERK: BuffStat;
	ENERGY_CHARGE: BuffStat;
	DASH2: BuffStat;
	DASH: BuffStat;
	MONSTER_RIDING: BuffStat;
	SPEED_INFUSION: BuffStat;
	HOMING_BEACON: BuffStat;
	toString(): string;
	values(): BuffStat[];
	valueOf(name: string): BuffStat;
	getValue(): number;
	isFirst(): boolean;
}
interface SkillEntry {
	masterlevel: number;
	skillevel: number;
	expiration: number;
	toString(): string;
}
interface TradeResult {
	NO_RESPONSE: TradeResult;
	PARTNER_CANCEL: TradeResult;
	SUCCESSFUL: TradeResult;
	UNSUCCESSFUL: TradeResult;
	UNSUCCESSFUL_UNIQUE_ITEM_LIMIT: TradeResult;
	UNSUCCESSFUL_ANOTHER_MAP: TradeResult;
	UNSUCCESSFUL_DAMAGED_FILES: TradeResult;
	values(): TradeResult[];
	valueOf(name: string): TradeResult;
}
interface DelayedQuestUpdate {
	UPDATE: DelayedQuestUpdate;
	FORFEIT: DelayedQuestUpdate;
	COMPLETE: DelayedQuestUpdate;
	INFO: DelayedQuestUpdate;
	values(): DelayedQuestUpdate[];
	valueOf(name: string): DelayedQuestUpdate;
}
interface Inventory {
	iterator(): java.util.Iterator;
	list(): null[];
	getType(): InventoryType;
	checked(): boolean;
	checked(yes: boolean): void;
	move(): void;
	findByName(item: string): Item;
	dispose(): void;
	getItem(slot: number): Item;
	countById(): number;
	findById(): Item;
	countNotOwnedById(): number;
	setSlotLimit(slot: number): void;
	unlockInventory(): void;
	lockInventory(): void;
	checkSpots(i: Character, chr: null[], items: boolean): boolean;
	checkSpots(itemQtyList: Character, itemId: null[], qty: null[], item: boolean): boolean;
	checkSpots(chr: Character, items: null[]): boolean;
	getNextFreeSlot(): number;
	addItemFromDB(item: Item): void;
	getSlotLimit(): number;
	addItem(item: Item): number;
	isFull(margin: number): boolean;
	isFull(): boolean;
	checkSpotsAndOwnership(i: Character, chr: null[], items: boolean): boolean;
	checkSpotsAndOwnership(itemQtyList: Character, itemHash: null[], qty: null[], item: boolean): boolean;
	checkSpotsAndOwnership(chr: Character, items: null[]): boolean;
	removeItem(slot: number): void;
	removeItem(slot: number, quantity: number, allowZero: boolean): void;
	findByCashId(): Item;
	removeSlot(): void;
	listById(): null[];
	getNumFreeSlot(): number;
	isEquipInventory(): boolean;
	freeSlotCountById(): number;
	linkedListById(): null[];
	checkSpot(item: Character, chr: null[]): boolean;
	checkSpot(chr: Character, item: Item): boolean;
	isFullAfterSomeItems(margin: number, used: number): boolean;
	isExtendableInventory(): boolean;
}
interface Disease {
	NULL: Disease;
	SLOW: Disease;
	SEDUCE: Disease;
	FISHABLE: Disease;
	ZOMBIFY: Disease;
	CONFUSE: Disease;
	STUN: Disease;
	POISON: Disease;
	SEAL: Disease;
	DARKNESS: Disease;
	WEAKEN: Disease;
	CURSE: Disease;
	values(): Disease[];
	valueOf(name: string): Disease;
	getValue(): number;
	ordinal(io: number): Disease;
	isFirst(): boolean;
	getMobSkillType(): MobSkillType;
	getBySkill(skill: MobSkillType): Disease;
	getRandom(): Disease;
}
interface Shop {
	getId(): number;
	sendShop(c: Client): void;
	buy(): void;
	recharge(): void;
	sell(): void;
	getNpcId(): number;
	createFromDB(query: number, shopId: boolean): Shop;
}
interface Fitness {
	getTime(): number;
	getTimeLeft(): number;
	resetTimes(): void;
	checkAndMessage(): void;
	isTimerStarted(): boolean;
	startFitness(): void;
}
interface MiniGameResult {
	WIN: MiniGameResult;
	LOSS: MiniGameResult;
	TIE: MiniGameResult;
	values(): MiniGameResult[];
	valueOf(name: string): MiniGameResult;
}
interface BuffStatValueHolder {
	effect: StatEffect;
	startTime: number;
	value: number;
	bestApplied: boolean;
}
interface CharacterFactoryRecipe {
	getInt(): number;
	setInt(v: number): void;
	getMap(): number;
	getLevel(): number;
	setStr(v: number): void;
	getStr(): number;
	getJob(): Job;
	getDex(): number;
	getLuk(): number;
	setLuk(v: number): void;
	setDex(v: number): void;
	getMeso(): number;
	setMaxMp(v: number): void;
	setMaxHp(v: number): void;
	getStartingSkillLevel(): null[];
	getRemainingSp(): number;
	getRemainingAp(): number;
	setRemainingSp(v: number): void;
	getMaxHp(): number;
	getMaxMp(): number;
	getStartingItems(): null[];
	setRemainingAp(v: number): void;
	setMeso(v: number): void;
	getTop(): number;
	getBottom(): number;
	getShoes(): number;
	addStartingItem(itemid: number, quantity: number, itemType: InventoryType): void;
	getWeapon(): number;
	addStartingSkillLevel(skill: Skill, level: number): void;
	addStartingEquipment(eqpItem: Item): void;
}
interface AutobanManager {
	setTimestamp(type: number, time: number, times: number): void;
	spam(type: number): void;
	spam(type: number, timestamp: number): void;
	getLastSpam(type: number): number;
	addPoint(fac: AutobanFactory, reason: string): void;
	addMiss(): void;
	resetMisses(): void;
}
interface AutobanFactory {
	MOB_COUNT: AutobanFactory;
	GENERAL: AutobanFactory;
	FIX_DAMAGE: AutobanFactory;
	DAMAGE_HACK: AutobanFactory;
	DISTANCE_HACK: AutobanFactory;
	PORTAL_DISTANCE: AutobanFactory;
	PACKET_EDIT: AutobanFactory;
	ACC_HACK: AutobanFactory;
	CREATION_GENERATOR: AutobanFactory;
	HIGH_HP_HEALING: AutobanFactory;
	FAST_HP_HEALING: AutobanFactory;
	FAST_MP_HEALING: AutobanFactory;
	GACHA_EXP: AutobanFactory;
	TUBI: AutobanFactory;
	SHORT_ITEM_VAC: AutobanFactory;
	ITEM_VAC: AutobanFactory;
	FAST_ITEM_PICKUP: AutobanFactory;
	FAST_ATTACK: AutobanFactory;
	MPCON: AutobanFactory;
	values(): AutobanFactory[];
	valueOf(name: string): AutobanFactory;
	getMaximum(): number;
	alert(): void;
	autoban(chr: Character, value: string): void;
	addPoint(ban: AutobanManager, reason: string): void;
	getExpire(): number;
	toggleIgnored(chrId: number): boolean;
	getIgnoredChrIds(): null[];
}
interface Ring {
	equals(): boolean;
	hashCode(): number;
	compareTo(other: Ring): number;
	compareTo(): number;
	getRingId(): number;
	loadFromDb(rs: number): Ring;
	getItemId(): number;
	equip(): void;
	unequip(): void;
	equipped(): boolean;
	createRing(): Pair;
	removeRing(ps: Ring): void;
	getPartnerRingId(): number;
	getPartnerName(): string;
	getPartnerChrId(): number;
}
interface NewYearCardRecord {
	getMessage(): string;
	getId(): number;
	loadPlayerNewYearCards(newyear: Character): void;
	isReceiverCardReceived(): boolean;
	stopNewYearCardTask(): void;
	isSenderCardDiscarded(): boolean;
	startNewYearCardTask(): void;
	getReceiverName(): string;
	getDateSent(): number;
	getDateReceived(): number;
	getSenderName(): string;
	getSenderId(): number;
	updateNewYearCard(ps: NewYearCardRecord): void;
	saveNewYearCard(rs: NewYearCardRecord): void;
	loadNewYearCard(newyear: number): NewYearCardRecord;
	getReceiverId(): number;
	setId(cardid: number): void;
	printNewYearRecords(nyc: Character): void;
	removeAllNewYearCard(): void;
	startPendingNewYearCardRequests(newyear: java.sql.Connection): void;
	isReceiverCardDiscarded(): boolean;
}
interface MiniGame extends AbstractMapObject {
	getType(): MapObjectType;
	broadcast(packet: Packet): void;
	getOwner(): Character;
	isOwner(chr: Character): boolean;
	removeVisitor(forceClose: boolean, challenger: Character): void;
	closeRoom(forceClose: boolean): void;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	minigameMatchStarted(): void;
	minigameMatchVisitorWins(forfeit: boolean): void;
	minigameMatchOwnerWins(forfeit: boolean): void;
	setPieceType(type: number): void;
	setMatchesToWin(type: number): void;
	sendOmok(c: Client, type: number): void;
	sendMatchCard(c: Client, type: number): void;
	setGameType(i: MiniGameType): void;
	getGameType(): MiniGameType;
	chat(c: Client, chat: string): void;
	getPieceType(): number;
	hasFreeSlot(): boolean;
	isVisitor(challenger: Character): boolean;
	addVisitor(challenger: Character): void;
	getLoser(): number;
	checkPassword(sentPw: string): boolean;
	shuffleList(): void;
	setFirstSlot(type: number): void;
	broadcastToOwner(packet: Packet): void;
	setVisitorPoints(): void;
	broadcastToVisitor(packet: Packet): void;
	isTieDenied(chr: Character): boolean;
	getFirstSlot(): number;
	setOwnerPoints(): void;
	getCardId(cardid: number): number;
	denyTie(chr: Character): void;
	minigameMatchDraw(): void;
	setPiece(x2: number, y2: number, x: number, y: Character): boolean;
	setQuitAfterGame(player: Character, quit: boolean): void;
	getVisitor(): Character;
	isOmok(): boolean;
	setLoser(type: number): void;
	isMatchInProgress(): boolean;
	getMatchesToWin(): number;
	getOwnerScore(): number;
	getVisitorScore(): number;
	getDescription(): string;
	getPassword(): string;
}
interface CooldownValueHolder {
	skillId: number;
	startTime: number;
	length: number;
}
interface Quest {
	getName(): string;
	start(a: Character, acts: number): void;
	getInstance(id: number): Quest;
	getId(): number;
	reset(chr: Character): void;
	complete(chr: Character, npc: number): void;
	complete(): void;
	clearCache(): void;
	clearCache(quest: number): void;
	getCompleteItemAmountNeeded(itemid: number): number;
	getStartItemAmountNeeded(itemid: number): number;
	isSameDayRepeatable(): boolean;
	canComplete(): boolean;
	getInfoNumber(): number;
	isExploitableQuest(questid: number): boolean;
	forfeit(chr: Character): boolean;
	forceStart(pr: Character, pid: number): boolean;
	forceComplete(chr: Character, npc: number): boolean;
	getTimeLimit(): number;
	isAutoComplete(): boolean;
	isAutoStart(): boolean;
	canStart(): boolean;
	restoreLostItem(): boolean;
	getMedalRequirement(): number;
	getInstanceFromInfoNumber(infoNumber: number): Quest;
	getMobAmountNeeded(mid: number): number;
	getInfoEx(ixReq: Status, e: number): string;
	getInfoEx(ixReq: Status): null[];
	getRelevantMobs(): null[];
	hasNextQuestAction(): boolean;
	getParentName(): string;
	getMatchedQuests(mq: string): null[];
	getNpcRequirement(checkEnd: boolean): number;
	loadAllQuests(): void;
	canQuestByInfoProgress(ixProgress: Character): boolean;
	hasScriptRequirement(checkEnd: boolean): boolean;
	canStartQuestByStatus(chr: Character): boolean;
}
interface Status {
	UNDEFINED: Status;
	NOT_STARTED: Status;
	STARTED: Status;
	COMPLETED: Status;
	values(): Status[];
	valueOf(name: string): Status;
	getId(): number;
	getById(l: number): Status;
}
interface SkillMacro {
	getName(): string;
	getShout(): number;
	getSkill1(): number;
	getSkill3(): number;
	getSkill2(): number;
	setSkill3(skill: number): void;
	setSkill1(skill: number): void;
	setSkill2(skill: number): void;
	getPosition(): number;
}
interface KeyBinding {
	getType(): number;
	getAction(): number;
}
interface BanishInfo {
	getMap(): number;
	getMsg(): string;
	getPortal(): string;
}
interface RockPaperScissor {
	answer(): boolean;
	dispose(c: Client): void;
	reward(c: Client): void;
	timeOut(c: Client): boolean;
	nextRound(c: Client): boolean;
}
interface ScriptInteraction {
	action(mode: number, type: number, selection: number, status: number): number;
}
interface StarBoost {
	toString(): string;
	getInt(): number;
	getMatk(): number;
	getDex(): number;
	getWatk(): number;
	getStr(): number;
	getLuk(): number;
	setInt(intStat: number): void;
	setLuk(luk: number): void;
	setStr(str: number): void;
	setDex(dex: number): void;
	setWatk(watk: number): void;
	setMatk(matk: number): void;
}
interface NPCConversationManager extends AbstractPlayerInteraction {
	c: Client;
	getName(): string;
	dispose(): void;
	getText(): string;
	changeRebirthJobCerezeth(jobid: number): void;
	canBeUsedAllianceName(name: string): boolean;
	getAllianceCapacity(): number;
	getStarForceEquipCraftingBonus(equip: Equip): StarBoost;
	getStarForceEquipCraftingBonus(slot: number): StarBoost;
	getStarForceEquipSpellTraceBonus(equip: Equip): number;
	getStarForceEquipSpellTraceBonus(slot: number): number;
	sendDimensionalMirror(text: string): void;
	getPlayerNPCByScriptid(pnpcObj: number): PlayerNPC;
	improveSuperiorEquips(nEquip: Equip, fail: boolean): void;
	getStarForceEquipSlot(): string;
	getMesoStarforceCost(nItemLevel: number, nReqLevel: number, superiorEquip: boolean): number;
	getInventoryAsStringFilter(): string;
	getEligibleEquipSelectionString(equip: number): string;
	createMarriageWishlist(): boolean;
	getInventoryAsStringNoDuplicates(): string;
	sendMarriageWishlist(chr: boolean): void;
	isUsingOldPqNpcStyle(): boolean;
	getNamesWhoDropsItem(itemId: number): object[];
	getInventoryAsString(): string;
	getAvailableSkillBooks(): object[];
	applyStarForceEquipCraftingBonus(equip: Equip, slot: number): Equip;
	getAvailableMasteryBooks(): object[];
	fieldLobbied2(field: number): boolean;
	mapClock(time: number): void;
	cancelCPQLobby(): void;
	fieldTaken2(field: number): boolean;
	completeQuest(id: number): boolean;
	startQuest(id: number): boolean;
	sendOk(text: string): void;
	sendOk(text: string, speaker: number): void;
	forceStartQuest(id: number): boolean;
	forceCompleteQuest(id: number): boolean;
	setHair(hair: number): void;
	getMeso(): number;
	gainExp(gain: number): void;
	setFace(face: number): void;
	gainMeso(gain: number): void;
	gainMeso(gain: number, show: boolean): void;
	displayGuildRanks(): void;
	getGiftLogCerezeth(giftid: string): number;
	changeJob(job: Job): void;
	getJobName(id: number): string;
	getItemEffect(itemId: number): StatEffect;
	getGender(): number;
	getParty(): Party;
	setGiftLogCerezeth(giftid: string): void;
	canSpawnPlayerNpc(mapid: number): boolean;
	sendNext(text: string): void;
	sendNext(text: string, speaker: number): void;
	resetStats(): void;
	getSkillDesc(skillid: number): string;
	createAlliance(name: string): Alliance;
	disbandAlliance(c: Client, allianceId: number): void;
	getNpc(): number;
	hasMerchant(): boolean;
	itemExists(itemid: number): boolean;
	getCharacters(map: MapleMap): null[];
	getEvent(): Event;
	fieldTaken(field: number): boolean;
	sendSimple(text: string, speaker: number): void;
	sendSimple(text: string): void;
	fieldLobbied(field: number): boolean;
	cpqCalcAvgLvl(): number;
	getEquipById(id: number): Equip;
	summonMob(mobid: number): void;
	summonMob(): void;
	improveEquipStats(nEquip: Equip, fail: boolean): void;
	rollSuccessChance(propPercent: number): boolean;
	calculateStatBoost(itemId: number, level: number): StarBoost;
	clearDrops(): void;
	makeNpc(npcid: number): void;
	makeNpc(npcid: number, x: number, y: number): void;
	getPortals(map: MapleMap): null[];
	sendYesNo(text: string): void;
	sendYesNo(text: string, speaker: number): void;
	sendYesNo(text: string, npcId: number): void;
	showEffect(effect: string): void;
	setGetText(text: string): void;
	getScriptName(): string;
	resetItemScript(): void;
	sendAcceptDecline(text: string): void;
	sendAcceptDecline(text: string, speaker: number): void;
	sendDefault(): void;
	getNpcObjectId(): number;
	sendPrev(text: string): void;
	sendPrev(text: string, speaker: number): void;
	sendNextPrev(text: string, speaker: number): void;
	sendNextPrev(text: string): void;
	sendGetText(text: string): void;
	sendStyle(text: string, styles: number[]): void;
	sendGetNumber(text: string, def: number, min: number, max: number): void;
	isItemScript(): boolean;
	changeJobById(a: number): void;
	getSkillsByJob(nfe: number): object[];
	gainTameness(): void;
	itemQuantity(itemid: number): number;
	setSkin(color: number): void;
	openShopNPC(id: number): void;
	resetMap(mapid: number): void;
	maxMastery(): void;
	createPyramid(): boolean;
	showFredrick(): void;
	partyMembersInMap(): number;
	upgradeAlliance(): void;
	divideTeams(): void;
	logLeaf(prize: string): void;
	changeKeyBinding(key: number, type: number, action: number): void;
	hasMerchantItems(): boolean;
	getCosmeticItem(): number;
	doGachapon(): void;
	getMapleCharacter(player: string): Character;
	cpqLobby2(mc: number): void;
	isCosmeticEquipped(itemid: number): boolean;
	answerCPQChallenge(accept: boolean): void;
	getChrById(id: number): Character;
	getNx(type: number): number;
	startCPQ(mc: Character, mpc: number): void;
	startCPQ2(mpc: Character, lobbyMap: number): void;
	sendCPQMapLists2(): boolean;
	getSkillBookInfo(itemid: number): string;
	sendCPQMapLists(): boolean;
	cpqLobby(mc: number): void;
	startAriantBattle(): string;
	sendMarriageGifts(gifts: null[]): void;
	letters(): string;
	challengeParty(mmo: number): void;
	logMessage(scriptName: string, message: string): void;
	gainStatItem(itemId: number, str: number, dex: number, luk: number, int_: number, matk: number, watk: number, acc: number, avoid: number, jump: number, speed: number, wdef: number, mdef: number, hp: number, mp: number, upgradeSlots: number): void;
	challengeParty2(mmo: number): void;
	getSpellTraceCost(nItemLevel: number, nReqLevel: number, superiorEquip: boolean): number;
	getReqLevel(itemid: number): number;
	isSuperior(nItemId: number): boolean;
	StarForceEquip(boom: Item): Item;
	getMonsters(): null[];
	getMapItems(): null[];
	masterQueryUpdate(con: string): boolean;
	masterQueryRaw(ps: string, con: string): null[];
	isEquip(id: number): boolean;
	getNPCs(): null[];
	masterQueryInsert(con: string): boolean;
	removeShopItem(con: number, sqle: ShopItem): void;
	getShopItems(shopId: number): null[];
	spyOnPlayer(upgradedValue: string, cleanStatValue: string): string;
	setShopItemPrice(): void;
	doesShopExist(shopId: number): boolean;
	isEndChat(mode: number, type: number): boolean;
	getMIIP(): ItemInformationProvider;
	getSFItem(slot: number): Item;
	getStarForceEquip(slot: number): Equip;
	addShopItem(): void;
	addShopToDb(con: number, sqle: number): void;
}
interface NpcTalkData {
	messageType: ScriptMessageType;
	speakerTypeID: number;
	param: number;
	prev: boolean;
	next: boolean;
	lenMin: number;
	lenMax: number;
	col: number;
	line: number;
	def: number;
	min: number;
	max: number;
	canadite: number[];
	speakerTemplateID: number;
	petData: PetTalkData[];
	msg: string;
	msgDefault: string;
	validSelections: null[];
	pattern: java.util.regex.Pattern;
	parseText(m: string): void;
}
interface ScriptMessageType {
	Say: ScriptMessageType;
	AskYesNo: ScriptMessageType;
	AskText: ScriptMessageType;
	AskNumber: ScriptMessageType;
	AskMenu: ScriptMessageType;
	AskQuiz: ScriptMessageType;
	AskSpeedQuiz: ScriptMessageType;
	AskAvatar: ScriptMessageType;
	AskMemberShopAvatar: ScriptMessageType;
	AskPet: ScriptMessageType;
	AskPetAll: ScriptMessageType;
	AskScript: ScriptMessageType;
	AskAccept: ScriptMessageType;
	AskBoxText: ScriptMessageType;
	AskSlideMenu: ScriptMessageType;
	AskCenter: ScriptMessageType;
	values(): ScriptMessageType[];
	valueOf(name: string): ScriptMessageType;
	getType(messageType: number): ScriptMessageType;
	getMsgType(): number;
}
interface SavedLocationType {
	FREE_MARKET: SavedLocationType;
	WORLDTOUR: SavedLocationType;
	FLORINA: SavedLocationType;
	INTRO: SavedLocationType;
	SUNDAY_MARKET: SavedLocationType;
	MIRROR: SavedLocationType;
	EVENT: SavedLocationType;
	BOSSPQ: SavedLocationType;
	HAPPYVILLE: SavedLocationType;
	MONSTER_CARNIVAL: SavedLocationType;
	DEVELOPER: SavedLocationType;
	HOME: SavedLocationType;
	values(): SavedLocationType[];
	valueOf(name: string): SavedLocationType;
	fromString(Str: string): SavedLocationType;
}
interface PartyQuest {
	getParty(): Party;
	getExp(PQ: string, level: number): number;
	getParticipants(): null[];
	removeParticipant(chr: Character): void;
}
interface GuildSummary {
	getName(): string;
	getAllianceId(): number;
	getLogoBG(): number;
	getLogoColor(): number;
	getLogoBGColor(): number;
	getLogo(): number;
}
interface BuddyAddResult {
	BUDDYLIST_FULL: BuddyAddResult;
	ALREADY_ON_LIST: BuddyAddResult;
	OK: BuddyAddResult;
	values(): BuddyAddResult[];
	valueOf(name: string): BuddyAddResult;
}
interface PetTalkData {
	pos: number;
	uniqueid: number;
}
interface ExpeditionType {
	BALROG_EASY: ExpeditionType;
	BALROG_NORMAL: ExpeditionType;
	SCARGA: ExpeditionType;
	PAPULATUS: ExpeditionType;
	SHOWA: ExpeditionType
	ZAKUM: ExpeditionType;
	HORNTAIL: ExpeditionType;
	CHAOS_ZAKUM: ExpeditionType;
	CHAOS_HORNTAIL: ExpeditionType;
	ARIANT: ExpeditionType;
	ARIANT1: ExpeditionType;
	ARIANT2: ExpeditionType;
	PINKBEAN: ExpeditionType;
	CWKPQ: ExpeditionType;
	VONLEON: ExpeditionType;
	CYGNUS: ExpeditionType;
	WILLSPIDER: ExpeditionType;
	VERUS: ExpeditionType;
	DARKNELL: ExpeditionType;
	KREXEL: ExpeditionType;
	CASTELLAN: ExpeditionType;
	LUCID: ExpeditionType;
	values(): ExpeditionType[];
	valueOf(name: string): ExpeditionType;
	getMaxLevel(): number;
	getMinLevel(): number;
	getMinSize(): number;
	getMaxSize(): number;
	getRegistrationMinutes(): number;
}
interface QuestActionManager extends NPCConversationManager {
	c: Client;
	dispose(): void;
	getQuest(): number;
	gainMeso(gain: number): void;
	gainExp(gain: number): void;
	completeQuest(): void;
	forceCompleteQuest(): boolean;
	forceStartQuest(): boolean;
	startQuest(): void;
	getMedalName(): string;
	isStart(): boolean;
}
interface MobLootEntry {
	run(): void;
}
interface Marriage extends EventInstanceManager {
	loadGiftItemsFromDb(it: Client, sqle: number): null[];
	getGiftItems(c: Client, groom: boolean): null[];
	isMarriageGroom(brideid: Character): boolean;
	getWishlistItems(groom: boolean): null[];
	initializeGiftItems(): void;
	claimGiftItems(con: Client, sqle: Character): boolean;
	addGiftItem(groom: boolean, item: Item): void;
	giftItemToSpouse(cid: number): boolean;
	removeGiftItem(groom: boolean, item: Item): void;
	saveGiftItemsToDb(c: Client, groom: boolean, cid: number): void;
	saveGiftItemsToDb(it: Client, con: null[], sqle: number): void;
	getGiftItem(): Item;
}
interface Ola {
	getTime(): number;
	getTimeLeft(): number;
	resetTimes(): void;
	isTimerStarted(): boolean;
	startOla(): void;
}
interface Service {
	dispose(): void;
	getService(): BaseService;
}
interface StateData {
}
interface MiniGameType {
	UNDEFINED: MiniGameType;
	OMOK: MiniGameType;
	MATCH_CARD: MiniGameType;
	values(): MiniGameType[];
	valueOf(name: string): MiniGameType;
	getValue(): number;
}
interface MessengerCharacter {
	getName(): string;
	equals(obj: object): boolean;
	hashCode(): number;
	getId(): number;
	getChannel(): number;
	setPosition(position: number): void;
	isOnline(): boolean;
	getPosition(): number;
}
interface BuddyList {
	remove(characterId: number): void;
	get(characterId: number): BuddylistEntry;
	get(): BuddylistEntry;
	put(entry: BuddylistEntry): void;
	contains(characterId: number): boolean;
	broadcast(): void;
	loadFromDb(ps: number): void;
	getBuddyIds(): number[];
	getBuddies(): null[];
	containsVisible(): boolean;
	pollPendingRequest(): CharacterNameAndId;
	getCapacity(): number;
	setCapacity(capacity: number): void;
	isFull(): boolean;
	addBuddyRequest(c: Client, cidFrom: number, nameFrom: string, channelFrom: number): void;
}
interface CharacterNameAndId {
	getName(): string;
	getId(): number;
}
interface MapObject {
	getType(): MapObjectType;
	setPosition(): void;
	getObjectId(): number;
	sendDestroyData(): void;
	sendSpawnData(): void;
	setObjectId(): void;
	nullifyPosition(): void;
	getPosition(): java.awt.Point;
}
interface MonsterBook {
	addCard(): void;
	loadCards(level: number): number;
	saveCards(level: java.sql.Connection, cardAndLevel: number): void;
	getCardSet(): java.util.Set;
	getBookLevel(): number;
	getCards(): java.util.Map;
	getNormalCard(): number;
	getCardTierSize(): number[];
	getSpecialCard(): number;
	getTotalCards(): number;
}
interface DelayedPacketCreation {
	sendPackets(): void;
}
interface WordTrack {
	getMessage(): string;
	getTime(): number;
	setTime(time: number): void;
	process(chr: Character, message: string): void;
	setMessage(message: string): void;
}
interface GMEvent {
	getName(): string;
	start(): void;
	isOpen(): boolean;
	setup(name: string, host: Character, world: World, channel: Channel, map: MapleMap): void;
	setName(name: string): void;
	getMembers(): null[];
	getHost(): Character;
	getMap(): MapleMap;
	getChannel(): Channel;
	cancel(): void;
	setMap(map: MapleMap): void;
	dispose(): void;
	registerPlayer(chr: Character): void;
	setChannel(ch: Channel): void;
	broadcastMessage(packet: Packet): void;
	getEvents(): null[];
	setHost(host: Character): void;
	warpOut(chrs: null[]): void;
	warpOut(): void;
	warpOut(chr: Character): void;
	announceWinnersOnDiscord(): boolean;
	announceEventOnDiscord(): boolean;
	loadLastEvent(): void;
	loadInfo(br: string): boolean;
	buildScore(): string;
	countdown(round: boolean): void;
	setStartTime(startTime: number): void;
	endTime(): void;
	gameOver(chrs: null[], time: number): void;
	gameOver(chr: Character): void;
	gameOver(chr: Character, time: number): void;
	gameOver(chrs: null[]): void;
	warpMembers(warpTo: MapleMap): void;
	warpMembers(warpTo: number): void;
	calcLasted(): number;
	updateLastEvent(): void;
	setLastEvent(lastEvent: LastEvent): void;
	addWin(chr: Character): void;
	getWinners(): java.util.Map;
	getLastEvent(): LastEvent;
	sendInstructions(i: Character): void;
	getInstuctions(): string;
	hasEvent(): boolean;
	insertToDB(): void;
	removeWin(chr: Character): void;
	setKillOnEntry(setTo: boolean): void;
	clearWinners(): void;
	setGate(setTo: boolean): void;
	setTeamWinner(teamWinner: string): void;
	getHelper(): string;
	cleanInstructions(): void;
	getDeaths(): null[];
	setPartyLimit(setTo: number): void;
	getPartyLimit(): number;
	canChalk(): boolean;
	setResurrection(setTo: boolean): void;
	setChalk(setTo: boolean): void;
	canResurrect(): boolean;
	getStartTime(): number;
}
interface MonsterListener {
	monsterKilled(): void;
	monsterDamaged(): void;
	monsterHealed(): void;
}
interface BuddylistEntry {
	getName(): string;
	equals(obj: object): boolean;
	hashCode(): number;
	getChannel(): number;
	isOnline(): boolean;
	setChannel(channel: number): void;
	getGroup(): string;
	isVisible(): boolean;
	getCharacterId(): number;
	setVisible(visible: boolean): void;
	changeGroup(group: string): void;
}
interface Messenger {
	getId(): number;
	getMembers(): null[];
	addMember(member: MessengerCharacter, position: number): void;
	removeMember(member: MessengerCharacter): void;
	getPositionByName(): number;
	getLowestPosition(): number;
}
interface AbstractMatchCheckerListener {
	onMatchCreated(): void;
	onMatchDismissed(): void;
	onMatchDeclined(): void;
	onMatchAccepted(): void;
}
interface AbstractPlayerInteraction {
	c: Client;
	getChar(): Character;
	message(message: string): void;
	removeAll(id: number): void;
	removeAll(id: number, cl: Client): void;
	getMap(map: number): MapleMap;
	getMap(): MapleMap;
	getLevel(): number;
	canHoldAll(itemids: null[], quantity: null[]): boolean;
	canHoldAll(): boolean;
	canHoldAllAfterRemoving(toRemove: null[], inv: null[], addItems: null[], canHold: null[]): boolean;
	mapMessage(type: number, message: string): void;
	isEventLeader(): boolean;
	removeHPQItems(): void;
	playerMessage(type: number, message: string): void;
	changeMusic(songName: string): void;
	displayAranIntro(): void;
	removeFromParty(iv: number, possesed: null[]): void;
	givePartyItems(): void;
	removePartyItems(mpc: number): void;
	givePartyExp(): void;
	givePartyExp(PQ: string): void;
	givePartyExp(member: string, player: boolean): void;
	guildMessage(type: number, message: string): void;
	getParty(): Party;
	isGuildLeader(): boolean;
	giveCharacterExp(amount: number, chr: Character): void;
	removeOne(id: number): void;
	removeOne(id: number, client: Client): void;
	getGuild(): Guild;
	disableMinimap(): void;
	isPartyLeader(): boolean;
	isAllReactorState(reactorId: number, state: number): boolean;
	teachSkill(skillid: number, level: number, masterLevel: number, expiration: number, force: boolean): void;
	teachSkill(skillid: number, level: number, masterLevel: number, expiration: number): void;
	showEffect(effect: string): void;
	talkGuide(message: string): void;
	guideHint(hint: number): void;
	spawnGuide(): void;
	updateAreaInfo(area: number, info: string): void;
	spawnNpc(npcId: number, pos: java.awt.Point): void;
	spawnNpc(npcId: number, pos: java.awt.Point, map: MapleMap): void;
	spawnNpc(npcId: number): void;
	containsAreaInfo(area: number, info: string): boolean;
	spawnMonster(id: number, x: number, y: number): void;
	getExpedition(type: ExpeditionType): Expedition;
	lockUI(): void;
	createExpedition(type: ExpeditionType): number;
	createExpedition(type: ExpeditionType, silent: boolean, minPlayers: number, maxPlayers: number): number;
	environmentChange(env: string, mode: number): void;
	openUI(ui: number): void;
	isLeader(): boolean;
	numberWithCommas(number: number): string;
	showInfoText(msg: string): void;
	getJobId(): number;
	applyReduceAvoid(monster: Monster): void;
	resetQuest(id: number): boolean;
	resetQuest(): boolean;
	getHourOfDay(): number;
	getCurrentTime(): number;
	applySealSkill(monster: Monster): void;
	sendOreStorage(): void;
	warp(mapid: number): void;
	warp(map: number, portal: string): void;
	warp(map: number, portal: number): void;
	warpMap(map: number): void;
	hasItem(itemid: number, quantity: number): boolean;
	hasItem(itemid: number): boolean;
	countMonster(): number;
	getQuestRecord(id: number): QuestStatus;
	getQuestStatus(id: number): number;
	resetQuestProgress(id: number, infoNumber: number): void;
	isQuestCompleted(): boolean;
	isQuestActive(id: number): boolean;
	evolvePet(slot: number, afterId: number): Item;
	getQuestNoRecord(id: number): QuestStatus;
	getWarpMap(map: number): MapleMap;
	getMarketPortalId(mapId: number): number;
	warpParty(id: number, fromMinId: number, fromMaxId: number): void;
	warpParty(): void;
	warpParty(id: number, portalId: number): void;
	warpParty(id: number): void;
	warpParty(map: number, portalName: string): void;
	getPlayer(): Character;
	getJob(): Job;
	getClient(): Client;
	getInventory(type: number): Inventory;
	getInventory(type: InventoryType): Inventory;
	resetMapObjects(mapid: number): void;
	haveItem(itemid: number): boolean;
	haveItem(itemid: number, quantity: number): boolean;
	canHold(itemid: number): boolean;
	canHold(itemid: number, quantity: number, removeItemid: number, removeQuantity: number): boolean;
	canHold(item: null[]): boolean;
	canHold(itemid: number, quantity: number): boolean;
	getEventManager(event: string): EventManager;
	haveItemWithId(itemid: number): boolean;
	haveItemWithId(itemid: number, checkEquipped: boolean): boolean;
	getEventInstance(): EventInstanceManager;
	getItemQuantity(itemid: number): number;
	getMapId(): number;
	mapSound(path: string): void;
	dropMessage(type: number, message: string): void;
	gainFame(delta: number): void;
	mapEffect(path: string): void;
	showIntro(path: string): void;
	showInfo(path: string): void;
	enableActions(): void;
	openNpc(npcid: number): void;
	openNpc(npcid: number, script: string): void;
	startQuest(id: number): boolean;
	startQuest(): boolean;
	startQuest(id: number, npc: number): boolean;
	forceCompleteQuest(id: number, npc: number): boolean;
	forceCompleteQuest(id: number): boolean;
	isQuestStarted(): boolean;
	forceStartQuest(id: number, npc: number): boolean;
	forceStartQuest(id: number): boolean;
	completeQuest(id: number): boolean;
	completeQuest(id: number, npc: number): boolean;
	completeQuest(): boolean;
	setQuestProgress(id: number, infoNumber: number, progress: string): void;
	setQuestProgress(id: number, infoNumber: number, progress: number): void;
	setQuestProgress(id: number, progress: string): void;
	setQuestProgress(id: number, progress: number): void;
	gainItem(id: number, quantity: number, randomStats: boolean, showMessage: boolean): Item;
	gainItem(id: number, quantity: number, randomStats: boolean, showMessage: boolean, expires: number): Item;
	gainItem(): Item;
	gainItem(id: number, show: boolean): void;
	gainItem(id: number, quantity: number, show: boolean): void;
	gainItem(id: number): void;
	gainItem(id: number, quantity: number): void;
	getQuestProgress(id: number): string;
	getQuestProgress(id: number, infoNumber: number): string;
	countAllMonstersOnMap(map: number): number;
	getQuestProgressInt(): number;
	resetAllQuestProgress(id: number): void;
	getUnclaimedMarriageGifts(): null[];
	getMonsterLifeFactory(mid: number): Monster;
	startDungeonInstance(dungeonid: number): boolean;
	getFirstJobStatRequirement(jobType: number): string;
	removeEquipFromSlot(slot: number): void;
	resetPartyDojoEnergy(): void;
	getExpeditionMemberNames(): string;
	cancelItem(id: number): void;
	showInstruction(msg: string, width: number, height: number): void;
	removeGuide(): void;
	resetDojoEnergy(): void;
	gainAndEquip(itemid: number, slot: number): void;
	getPlayerCount(mapid: number): number;
	resetMap(): void;
	displayGuide(num: number): void;
	goDojoUp(): void;
	useItem(id: number): void;
	dojoEnergy(): void;
	playSound(sound: string): void;
	isLeaderExpedition(type: ExpeditionType): boolean;
	getDriedPets(): null[];
	earnTitle(msg: string): void;
	getBossLogEntries(boss: number): number;
	canGetFirstJob(jobType: number): boolean;
	getJailTimeLeft(): number;
	npcTalk(npcid: number, message: string): void;
	getPyramid(): Pyramid;
	endExpedition(exped: Expedition): void;
	unlockUI(): void;
	startEventTimer(): TotemEventData;
	reachedRewardLimit(type: ExpeditionType): boolean;
	logToConsole(message: string): void;
	weakenAreaBoss(monsterId: number, message: string): void;
	logMessage(scriptName: string, message: string): void;
}
interface Pyramid extends PartyQuest {
	timer(): number;
	warp(): void;
	miss(): void;
	kill(): void;
	sendScore(): void;
	checkBuffs(): void;
	startGaugeSchedule(): void;
	broadcastInfo(): void;
	useSkill(): boolean;
	cool(): void;
}
interface PyramidMode {
	EASY: PyramidMode;
	NORMAL: PyramidMode;
	HARD: PyramidMode;
	HELL: PyramidMode;
	values(): PyramidMode[];
	valueOf(name: string): PyramidMode;
	getMode(): number;
}
interface MapItem extends AbstractMapObject {
	getType(): MapObjectType;
	getItem(): Item;
	getItemId(): number;
	getMeso(): number;
	getDropTime(): number;
	canBePickedBy(chr: Character): boolean;
	isPickedUp(): boolean;
	lockItem(): void;
	getQuest(): number;
	getDropper(): MapObject;
	unlockItem(): void;
	isPlayerDrop(): boolean;
	sendDestroyData(client: Client): void;
	sendSpawnData(client: Client): void;
	getOwnerId(): number;
	isFFADrop(): boolean;
	getDropType(): number;
	hasClientsideOwnership(player: Character): boolean;
	hasExpiredOwnershipTime(): boolean;
	getClientsideOwnerId(): number;
	setDropTime(time: number): void;
	setPickedUp(pickedUp: boolean): void;
	getPartyOwnerId(): number;
	setPartyOwnerId(partyid: number): void;
	getOwnerClient(): Client;
}
interface Skill {
	getId(): number;
	getElement(): Element;
	setElement(elem: Element): void;
	getMaxLevel(): number;
	getEffect(level: number): StatEffect;
	isBeginnerSkill(): boolean;
	getAction(): boolean;
	getAnimationTime(): number;
	incAnimationTime(time: number): void;
	setAction(act: boolean): void;
	isFourthJob(): boolean;
	addLevelEffect(effect: StatEffect): void;
	setAnimationTime(time: number): void;
}
interface BuddyOperation {
	ADDED: BuddyOperation;
	DELETED: BuddyOperation;
	values(): BuddyOperation[];
	valueOf(name: string): BuddyOperation;
}
interface SkinColor {
	NORMAL: SkinColor;
	DARK: SkinColor;
	BLACK: SkinColor;
	PALE: SkinColor;
	BLUE: SkinColor;
	GREEN: SkinColor;
	WHITE: SkinColor;
	PINK: SkinColor;
	values(): SkinColor[];
	valueOf(name: string): SkinColor;
	getId(): number;
	getById(l: number): SkinColor;
}
interface Type {
	LOGIN: Type;
	CHANNEL: Type;
	values(): Type[];
	valueOf(name: string): Type;
}
interface NpcMakerCraftingService {
	useMakerPermissionAtkUp(): boolean;
	getMakerSkillLevel(chr: Character): number;
}
interface ChannelServices {
	MOB_STATUS: ChannelServices;
	MOB_ANIMATION: ChannelServices;
	MOB_CLEAR_SKILL: ChannelServices;
	MOB_MIST: ChannelServices;
	EVENT: ChannelServices;
	OVERALL: ChannelServices;
	values(): ChannelServices[];
	valueOf(name: string): ChannelServices;
	createService(): Service;
	enumValues(): ChannelServices[];
	enumValues(): java.lang.Enum[];
}
interface AbstractMapObject {
	getType(): MapObjectType;
	setPosition(position: java.awt.Point): void;
	getObjectId(): number;
	setObjectId(id: number): void;
	nullifyPosition(): void;
	getPosition(): java.awt.Point;
}
interface MiniDungeon {
	close(): void;
	dispose(): void;
	registerPlayer(chr: Character): boolean;
	unregisterPlayer(chr: Character): boolean;
}
interface SpawnPoint {
	getTeam(): number;
	getFh(): number;
	getMonster(): Monster;
	getF(): number;
	getMonsterId(): number;
	shouldForceSpawn(): boolean;
	shouldSpawn(): boolean;
	getDenySpawn(): boolean;
	setDenySpawn(val: boolean): void;
	getSpawned(): number;
	getMobTime(): number;
	getPosition(): java.awt.Point;
}
interface ActivateItemReactor {
	run(): void;
}
interface PartyOperation {
	JOIN: PartyOperation;
	LEAVE: PartyOperation;
	EXPEL: PartyOperation;
	DISBAND: PartyOperation;
	SILENT_UPDATE: PartyOperation;
	LOG_ONOFF: PartyOperation;
	CHANGE_LEADER: PartyOperation;
	values(): PartyOperation[];
	valueOf(name: string): PartyOperation;
}
interface AbstractLoadedLife extends AbstractAnimatedMapObject {
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	isHidden(): boolean;
	getId(): number;
	setFh(fh: number): void;
	getFh(): number;
	setRx1(rx1: number): void;
	setRx0(rx0: number): void;
	setCy(cy: number): void;
	getF(): number;
	getCy(): number;
	setF(f: number): void;
	setHide(hide: boolean): void;
	getStartFh(): number;
	getRx0(): number;
	getRx1(): number;
}
interface LastEvent {
	getName(): string;
	getHost(): string;
	getEnded(): java.sql.Timestamp;
	getLasted(): number;
	getWinners(): string;
}
interface Pair {
	left: object;
	right: object;
	equals(obj: object): boolean;
	toString(): string;
	hashCode(): number;
	getLeft(): object;
	getRight(): object;
}
interface QuestStatus {
	setExpirationTime(expirationTime: number): void;
	setCompleted(completed: number): void;
	getQuest(): Quest;
	getStatus(): Status;
	getNpc(): number;
	resetProgress(id: number): void;
	resetAllProgress(): void;
	setCustomData(customData: string): void;
	progress(id: number): boolean;
	setForfeited(forfeited: number): void;
	setProgress(id: number, pr: string): void;
	addMedalMap(mapid: number): boolean;
	setCompletionTime(completionTime: number): void;
	getExpirationTime(): number;
	getInfoNumber(): number;
	getProgress(): java.util.Map;
	getProgress(id: number): string;
	getCompleted(): number;
	getForfeited(): number;
	getMedalMaps(): null[];
	getCompletionTime(): number;
	getQuestID(): number;
	madeProgress(): boolean;
	setNpc(npc: number): void;
	getInfoEx(index: number): string;
	getInfoEx(): null[];
	getMedalProgress(): number;
	getCustomData(): string;
	getProgressData(): string;
	setStatus(status: Status): void;
}
interface Dragon extends AbstractAnimatedMapObject {
	IDLE_MOVEMENT_PACKET_LENGTH: number;
	getType(): MapObjectType;
	getOwner(): Character;
	getObjectId(): number;
	sendDestroyData(c: Client): void;
	sendSpawnData(client: Client): void;
}
interface WeaponType {
	NOT_A_WEAPON: WeaponType;
	GENERAL1H_SWING: WeaponType;
	GENERAL1H_STAB: WeaponType;
	GENERAL2H_SWING: WeaponType;
	GENERAL2H_STAB: WeaponType;
	BOW: WeaponType;
	CLAW: WeaponType;
	CROSSBOW: WeaponType;
	DAGGER_THIEVES: WeaponType;
	DAGGER_OTHER: WeaponType;
	GUN: WeaponType;
	KNUCKLE: WeaponType;
	POLE_ARM_SWING: WeaponType;
	POLE_ARM_STAB: WeaponType;
	SPEAR_STAB: WeaponType;
	SPEAR_SWING: WeaponType;
	STAFF: WeaponType;
	SWORD1H: WeaponType;
	SWORD2H: WeaponType;
	WAND: WeaponType;
	values(): WeaponType[];
	valueOf(name: string): WeaponType;
	getMaxDamageMultiplier(): number;
}
interface DoorObject extends AbstractMapObject {
	update(townPortalId: number, toPosition: java.awt.Point): void;
	getType(): MapObjectType;
	getFrom(): MapleMap;
	sendDestroyData(client: Client, partyUpdate: boolean): void;
	sendDestroyData(): void;
	sendSpawnData(client: Client, launched: boolean): void;
	sendSpawnData(client: Client): void;
	getTown(): MapleMap;
	getOwnerId(): number;
	getTo(): MapleMap;
	toPosition(): java.awt.Point;
	inTown(): boolean;
	setPairOid(oid: number): void;
	getPairOid(): number;
	getAreaPosition(): java.awt.Point;
	warp(chr: Character): void;
	getArea(): MapleMap;
}
interface CashShop {
	save(item: java.sql.Connection): void;
	open(b: boolean): void;
	getInventory(): null[];
	getCash(type: number): number;
	gainCash(type: number, cash: number): void;
	gainCash(type: number, buyItem: CashItem, world: number): void;
	isOpened(): boolean;
	removeFromInventory(item: Item): void;
	openCashShopSurprise(): Pair;
	loadGifts(): null[];
	addToInventory(item: Item): void;
	gift(recipient: number, from: string, message: string, sn: number): void;
	gift(): void;
	findByCashId(item: number): Item;
	addToWishList(sn: number): void;
	clearWishList(): void;
	generateCouponItem(itemId: number, quantity: number): Item;
	getAvailableNotes(): number;
	canNoteThankName(name: string): boolean;
	deleteGiftName(name: string): void;
	decreaseNotes(): void;
	getWishList(): null[];
}
interface CashItem {
	getCount(): number;
	getSN(): number;
	getItemId(): number;
	getPrice(): number;
	toItem(): Item;
	isOnSale(): boolean;
}
interface CashItemFactory {
	getPackage(sn: number): null[];
	isPackage(itemId: number): boolean;
	getItem(sn: number): CashItem;
	loadAllCashItems(): void;
	getRandomCashItem(): CashItem;
	reloadSpecialCashItems(): void;
	getSpecialCashItems(): null[];
}
interface SpecialCashItem {
	getSN(): number;
	getInfo(): number;
	getModifier(): number;
}
interface MonsterAggroCoordinator {
	dispose(): void;
	removePuppetAggro(cid: number): void;
	addPuppetAggro(player: Character): void;
	getPuppetAggroList(): null[];
	addAggroDamage(): void;
	removeAggroEntries(mob: Monster): void;
	isLeadingCharacterAggro(pae: Monster, map: Character): boolean;
	stopAggroCoordinator(): void;
	startAggroCoordinator(): void;
	runSortLeadingCharactersAggro(): void;
}
interface PlayerAggroEntry {
}
interface ItemScriptManager {
	getInstance(): ItemScriptManager;
	runItemScript(c: Client, scriptItem: ScriptedItem): void;
}
interface MapScriptManager extends AbstractScriptManager {
	getInstance(): MapScriptManager;
	reloadScripts(): void;
	runMapScript(): boolean;
}
interface PortalScriptManager extends AbstractScriptManager {
	getInstance(): PortalScriptManager;
	reloadPortalScripts(): void;
	executePortalScript(): boolean;
}
interface QuestScriptManager extends AbstractScriptManager {
	start(): void;
	start(iv: Client, qm: number, t: number): void;
	end(iv: Client, qm: number, t: number): void;
	end(): void;
	getInstance(): QuestScriptManager;
	dispose(c: Client): void;
	dispose(qm: QuestActionManager, c: Client): void;
	getQM(c: Client): QuestActionManager;
	reloadQuestScripts(): void;
	raiseOpen(iv: Client, qm: number, t: number): void;
}
interface ItemConstants {
	LOCK: number;
	SPIKES: number;
	KARMA_USE: number;
	COLD: number;
	UNTRADEABLE: number;
	KARMA_EQP: number;
	SANDBOX: number;
	PET_COME: number;
	ACCOUNT_SHARING: number;
	MERGE_UNTRADEABLE: number;
	STORAGE_MAX_SLOT_SIZE: number;
	EXPIRING_ITEMS: boolean;
	permanentItemids: java.util.Set;
	makerItemIds: java.util.Set;
	useBlockedIds: java.util.Set;
	etcBlockedIds: java.util.Set;
	rebirth1: java.util.Set;
	rebirth2: java.util.Set;
	rebirth3: java.util.Set;
	getRestrictedItemsForRebirth(rebirths: number): java.util.Set;
	getItemRebirthRequirement(itemId: number): number;
	isFood(itemId: number): boolean;
	isThrowingStar(itemId: number): boolean;
	isPotion(itemId: number): boolean;
	isBullet(itemId: number): boolean;
	isArrowForBow(itemId: number): boolean;
	isArrowForCrossBow(itemId: number): boolean;
	isRateCoupon(itemId: number): boolean;
	isExpCoupon(couponId: number): boolean;
	isConsumable(itemId: number): boolean;
	isModifierScroll(scrollId: number): boolean;
	isPlayerShop(itemId: number): boolean;
	isRechargeable(itemId: number): boolean;
	isNewYearCardUse(itemId: number): boolean;
	isExpirablePet(itemId: number): boolean;
	isPet(itemId: number): boolean;
	isAccessory(itemId: number): boolean;
	isAntibanishScroll(itemId: number): boolean;
	isTownScroll(itemId: number): boolean;
	isTaming(itemId: number): boolean;
	isChaosScroll(scrollId: number): boolean;
	isHiredMerchant(itemId: number): boolean;
	isMakerReagent(itemId: number): boolean;
	isOverall(itemId: number): boolean;
	isPartyItem(itemId: number): boolean;
	isCashStore(itemId: number): boolean;
	isMapleLife(itemId: number): boolean;
	isPermanentItem(itemId: number): boolean;
	isFlagModifier(scrollId: number, flag: number): boolean;
	getInventoryType(itemId: number): InventoryType;
	isArrow(itemId: number): boolean;
	isCleanSlate(scrollId: number): boolean;
	isNewYearCardEtc(itemId: number): boolean;
	getFlagByInt(type: number): number;
	isMedal(itemId: number): boolean;
	isEquipment(itemId: number): boolean;
	isFace(itemId: number): boolean;
	isFishingChair(itemId: number): boolean;
	isHair(itemId: number): boolean;
	isWeapon(itemId: number): boolean;
}
interface GameConstants {
	WORLD_NAMES: string[];
	stats: string[];
	CASH_DATA: number[];
	CPQ_DISEASES: Disease[];
	MAX_FIELD_MOB_DAMAGE: number;
	GOTO_TOWNS: java.util.Map;
	GOTO_AREAS: java.util.Map;
	GAME_SONGS: null[];
	ordinal(i: number): string;
	parseNumber(e: string): java.lang.Number;
	isHallOfFameMap(mapid: number): boolean;
	isAranSkills(skill: number): boolean;
	isCygnus(job: number): boolean;
	isPqSkill(skill: number): boolean;
	getJobBranch(job: Job): number;
	isAran(job: number): boolean;
	getCustomType(customKeyset: boolean): number[];
	getCustomAction(customKeyset: boolean): number[];
	getCustomKey(customKeyset: boolean): number[];
	getSkillBook(job: number): number;
	isHiddenSkills(skill: number): boolean;
	isGMSkills(skill: number): boolean;
	isMerchantLocked(map: MapleMap): boolean;
	isDojoBossArea(mapid: number): boolean;
	isFreeMarketRoom(mapid: number): boolean;
	bannedBindSkills(skill: number): boolean;
	isPqSkillMap(mapid: number): boolean;
	getHallOfFameMapid(job: Job): number;
	getJobMaxLevel(job: Job): number;
	isInJobTree(i: number, skillId: number): boolean;
	getJobName(job: number): string;
	isFinisherSkill(skillId: number): boolean;
	isMedalQuest(questid: number): boolean;
	getMonsterHP(level: number): number;
	hasSPTable(job: Job): boolean;
	numberWithCommas(i: number): string;
	getPlayerBonusMesoRate(slot: number): number;
	getJobUpgradeLevelRange(jobbranch: number): number;
	isAriantColiseumArena(mapid: number): boolean;
	canPnpcBranchUseScriptId(branch: number, scriptId: number): boolean;
	getPlayerBonusDropRate(slot: number): number;
	isAriantColiseumLobby(mapid: number): boolean;
	getPlayerBonusExpRate(slot: number): number;
	getHallOfFameBranch(job: Job, mapid: number): number;
	isPodiumHallOfFameMap(mapid: number): boolean;
	getOverallJobRankByScriptId(scriptId: number): number;
	getChangeJobSpUpgrade(jobbranch: number): number;
}
interface YamlConfig {
	CONFIG_FILE_NAME: string;
	config: YamlConfig;
	worlds: WorldConfig[];
	server: ServerConfig;
}
interface WorldConfig {
	flag: number;
	server_message: string;
	event_message: string;
	why_am_i_recommended: string;
	channels: number;
	exp_rate: number;
	meso_rate: number;
	drop_rate: number;
	boss_drop_rate: number;
	quest_rate: number;
	travel_rate: number;
	fishing_rate: number;
}
interface ServerConfig {
	DB_URL_FORMAT: string;
	DB_HOST: string;
	DB_USER: string;
	DB_PASS: string;
	INIT_CONNECTION_POOL_TIMEOUT: number;
	WORLDS: number;
	WLDLIST_SIZE: number;
	CHANNEL_SIZE: number;
	CHANNEL_LOAD: number;
	CHANNEL_LOCKS: number;
	RESPAWN_INTERVAL: number;
	PURGING_INTERVAL: number;
	RANKING_INTERVAL: number;
	COUPON_INTERVAL: number;
	UPDATE_INTERVAL: number;
	ENABLE_PIC: boolean;
	ENABLE_PIN: boolean;
	BYPASS_PIC_EXPIRATION: number;
	BYPASS_PIN_EXPIRATION: number;
	AUTOMATIC_REGISTER: boolean;
	BCRYPT_MIGRATION: boolean;
	COLLECTIVE_CHARSLOT: boolean;
	DETERRED_MULTICLIENT: boolean;
	MAX_ALLOWED_ACCOUNT_HWID: number;
	MAX_ACCOUNT_LOGIN_ATTEMPT: number;
	LOGIN_ATTEMPT_DURATION: number;
	HOST: string;
	LANHOST: string;
	LOCALHOST: string;
	GMSERVER: boolean;
	SHUTDOWNHOOK: boolean;
	USE_CUSTOM_KEYSET: boolean;
	USE_DEBUG: boolean;
	USE_DEBUG_SHOW_INFO_EQPEXP: boolean;
	USE_DEBUG_SHOW_RCVD_PACKET: boolean;
	USE_DEBUG_SHOW_RCVD_MVLIFE: boolean;
	USE_DEBUG_SHOW_PACKET: boolean;
	USE_SUPPLY_RATE_COUPONS: boolean;
	USE_IP_VALIDATION: boolean;
	USE_CHARACTER_ACCOUNT_CHECK: boolean;
	USE_MAXRANGE: boolean;
	USE_MAXRANGE_ECHO_OF_HERO: boolean;
	USE_MTS: boolean;
	USE_CPQ: boolean;
	USE_AUTOHIDE_GM: boolean;
	USE_BUYBACK_SYSTEM: boolean;
	USE_FIXED_RATIO_HPMP_UPDATE: boolean;
	USE_FAMILY_SYSTEM: boolean;
	USE_DUEY: boolean;
	USE_RANDOMIZE_HPMP_GAIN: boolean;
	USE_STORAGE_ITEM_SORT: boolean;
	USE_ITEM_SORT: boolean;
	USE_ITEM_SORT_BY_NAME: boolean;
	USE_PARTY_FOR_STARTERS: boolean;
	USE_AUTOASSIGN_STARTERS_AP: boolean;
	USE_AUTOASSIGN_SECONDARY_CAP: boolean;
	USE_STARTING_AP_4: boolean;
	USE_AUTOBAN: boolean;
	USE_AUTOBAN_LOG: boolean;
	USE_AUTOSAVE: boolean;
	USE_SERVER_AUTOASSIGNER: boolean;
	USE_REFRESH_RANK_MOVE: boolean;
	USE_ENFORCE_ADMIN_ACCOUNT: boolean;
	USE_ENFORCE_NOVICE_EXPRATE: boolean;
	USE_ENFORCE_HPMP_SWAP: boolean;
	USE_ENFORCE_MOB_LEVEL_RANGE: boolean;
	USE_ENFORCE_JOB_LEVEL_RANGE: boolean;
	USE_ENFORCE_JOB_SP_RANGE: boolean;
	USE_ENFORCE_ITEM_SUGGESTION: boolean;
	USE_ENFORCE_UNMERCHABLE_CASH: boolean;
	USE_ENFORCE_UNMERCHABLE_PET: boolean;
	USE_ENFORCE_MERCHANT_SAVE: boolean;
	USE_ENFORCE_MDOOR_POSITION: boolean;
	USE_SPAWN_CLEAN_MDOOR: boolean;
	USE_SPAWN_LOOT_ON_ANIMATION: boolean;
	USE_SPAWN_RELEVANT_LOOT: boolean;
	USE_ERASE_PERMIT_ON_OPENSHOP: boolean;
	USE_ERASE_UNTRADEABLE_DROP: boolean;
	USE_ERASE_PET_ON_EXPIRATION: boolean;
	USE_BUFF_MOST_SIGNIFICANT: boolean;
	USE_BUFF_EVERLASTING: boolean;
	USE_MULTIPLE_SAME_EQUIP_DROP: boolean;
	USE_BANISHABLE_TOWN_SCROLL: boolean;
	USE_ENABLE_FULL_RESPAWN: boolean;
	USE_ENABLE_CHAT_LOG: boolean;
	USE_REBIRTH_SYSTEM: boolean;
	USE_MAP_OWNERSHIP_SYSTEM: boolean;
	USE_FISHING_SYSTEM: boolean;
	USE_NPCS_SCRIPTABLE: boolean;
	USE_OLD_GMS_STYLED_PQ_NPCS: boolean;
	USE_ENABLE_SOLO_EXPEDITIONS: boolean;
	USE_ENABLE_DAILY_EXPEDITIONS: boolean;
	USE_ENABLE_RECALL_EVENT: boolean;
	USE_ANNOUNCE_SHOPITEMSOLD: boolean;
	USE_ANNOUNCE_CHANGEJOB: boolean;
	USE_ANNOUNCE_NX_COUPON_LOOT: boolean;
	USE_JOINT_CASHSHOP_INVENTORY: boolean;
	USE_CLEAR_OUTDATED_COUPONS: boolean;
	ALLOW_CASHSHOP_NAME_CHANGE: boolean;
	ALLOW_CASHSHOP_WORLD_TRANSFER: boolean;
	USE_MAKER_PERMISSIVE_ATKUP: boolean;
	USE_MAKER_FEE_HEURISTICS: boolean;
	USE_ENABLE_CUSTOM_NPC_SCRIPT: boolean;
	USE_STARTER_MERGE: boolean;
	BLOCK_GENERATE_CASH_ITEM: boolean;
	USE_WHOLE_SERVER_RANKING: boolean;
	EQUIP_EXP_RATE: number;
	PQ_BONUS_EXP_RATE: number;
	EXP_SPLIT_LEVEL_INTERVAL: number;
	EXP_SPLIT_LEECH_INTERVAL: number;
	EXP_SPLIT_MVP_MOD: number;
	EXP_SPLIT_COMMON_MOD: number;
	PARTY_BONUS_EXP_RATE: number;
	TIMEZONE: string;
	CHARSET: string;
	USE_DISPLAY_NUMBERS_WITH_COMMA: boolean;
	USE_UNITPRICE_WITH_COMMA: boolean;
	MAX_MONITORED_BUFFSTATS: number;
	MAX_AP: number;
	MAX_EVENT_LEVELS: number;
	BLOCK_NPC_RACE_CONDT: number;
	TOT_MOB_QUEST_REQUIREMENT: number;
	MOB_REACTOR_REFRESH_TIME: number;
	PARTY_SEARCH_REENTRY_LIMIT: number;
	NAME_CHANGE_COOLDOWN: number;
	WORLD_TRANSFER_COOLDOWN: number;
	INSTANT_NAME_CHANGE: boolean;
	REBIRTH_NPC_ID: number;
	ITEM_EXPIRE_TIME: number;
	KITE_EXPIRE_TIME: number;
	ITEM_MONITOR_TIME: number;
	LOCK_MONITOR_TIME: number;
	ITEM_EXPIRE_CHECK: number;
	ITEM_LIMIT_ON_MAP: number;
	MAP_VISITED_SIZE: number;
	MAP_DAMAGE_OVERTIME_INTERVAL: number;
	MAP_DAMAGE_OVERTIME_COUNT: number;
	MOB_STATUS_MONITOR_PROC: number;
	MOB_STATUS_MONITOR_LIFE: number;
	MOB_STATUS_AGGRO_PERSISTENCE: number;
	MOB_STATUS_AGGRO_INTERVAL: number;
	USE_AUTOAGGRO_NEARBY: boolean;
	USE_PERFECT_GM_SCROLL: boolean;
	USE_PERFECT_SCROLLING: boolean;
	USE_ENHANCED_CHSCROLL: boolean;
	USE_ENHANCED_CRAFTING: boolean;
	USE_ENHANCED_CLEAN_SLATE: boolean;
	SCROLL_CHANCE_ROLLS: number;
	CHSCROLL_STAT_RATE: number;
	CHSCROLL_STAT_RANGE: number;
	USE_ULTRA_NIMBLE_FEET: boolean;
	USE_ULTRA_RECOVERY: boolean;
	USE_ULTRA_THREE_SNAILS: boolean;
	USE_FULL_ARAN_SKILLSET: boolean;
	USE_FAST_REUSE_HERO_WILL: boolean;
	USE_ANTI_IMMUNITY_CRASH: boolean;
	USE_UNDISPEL_HOLY_SHIELD: boolean;
	USE_FULL_HOLY_SYMBOL: boolean;
	USE_ADD_SLOTS_BY_LEVEL: boolean;
	USE_ADD_RATES_BY_LEVEL: boolean;
	USE_STACK_COUPON_RATES: boolean;
	USE_PERFECT_PITCH: boolean;
	REBIRTH_FIRST_RATE: number;
	REBIRTH_SECOND_RATE: number;
	REBIRTH_THIRD_RATE: number;
	REBIRTH_RESET_LEVEL: number;
	AUTOLOOT_ITEM_ID: number;
	JUMPQUEST_CUSTOM_EXP_MESOS_REWARD: number;
	JUMPQUEST_BASE_EXP_REWARD: number;
	JUMPQUEST_BASE_MESOS_REWARD: number;
	USE_QUEST_RATE: boolean;
	QUEST_POINT_REPEATABLE_INTERVAL: number;
	QUEST_POINT_REQUIREMENT: number;
	QUEST_POINT_PER_QUEST_COMPLETE: number;
	QUEST_POINT_PER_EVENT_CLEAR: number;
	CREATE_GUILD_MIN_PARTNERS: number;
	CREATE_GUILD_COST: number;
	CHANGE_EMBLEM_COST: number;
	EXPAND_GUILD_BASE_COST: number;
	EXPAND_GUILD_TIER_COST: number;
	EXPAND_GUILD_MAX_COST: number;
	FAMILY_REP_PER_KILL: number;
	FAMILY_REP_PER_BOSS_KILL: number;
	FAMILY_REP_PER_LEVELUP: number;
	FAMILY_MAX_GENERATIONS: number;
	USE_EQUIPMNT_LVLUP_SLOTS: boolean;
	USE_EQUIPMNT_LVLUP_POWER: boolean;
	USE_EQUIPMNT_LVLUP_CASH: boolean;
	USE_SPIKES_AVOID_BANISH: boolean;
	MAX_EQUIPMNT_LVLUP_STAT_UP: number;
	MAX_EQUIPMNT_STAT: number;
	USE_EQUIPMNT_LVLUP: number;
	USE_CHAIR_EXTRAHEAL: boolean;
	CHAIR_EXTRA_HEAL_MULTIPLIER: number;
	CHAIR_EXTRA_HEAL_MAX_DELAY: number;
	PLAYERNPC_INITIAL_X: number;
	PLAYERNPC_INITIAL_Y: number;
	PLAYERNPC_AREA_X: number;
	PLAYERNPC_AREA_Y: number;
	PLAYERNPC_AREA_STEPS: number;
	PLAYERNPC_ORGANIZE_AREA: boolean;
	PLAYERNPC_AUTODEPLOY: boolean;
	USE_COMPULSORY_AUTOPOT: boolean;
	USE_EQUIPS_ON_AUTOPOT: boolean;
	PET_AUTOHP_RATIO: number;
	PET_AUTOMP_RATIO: number;
	PET_EXHAUST_COUNT: number;
	MOUNT_EXHAUST_COUNT: number;
	PETS_NEVER_HUNGRY: boolean;
	GM_PETS_NEVER_HUNGRY: boolean;
	EVENT_MAX_GUILD_QUEUE: number;
	EVENT_LOBBY_DELAY: number;
	USE_FAST_DOJO_UPGRADE: boolean;
	USE_DEADLY_DOJO: boolean;
	DOJO_ENERGY_ATK: number;
	DOJO_ENERGY_DMG: number;
	WEDDING_RESERVATION_DELAY: number;
	WEDDING_RESERVATION_TIMEOUT: number;
	WEDDING_RESERVATION_INTERVAL: number;
	WEDDING_BLESS_EXP: number;
	WEDDING_GIFT_LIMIT: number;
	WEDDING_BLESSER_SHOWFX: boolean;
	USE_BUYBACK_WITH_MESOS: boolean;
	BUYBACK_FEE: number;
	BUYBACK_LEVEL_STACK_FEE: number;
	BUYBACK_MESO_MULTIPLIER: number;
	BUYBACK_RETURN_MINUTES: number;
	BUYBACK_COOLDOWN_MINUTES: number;
	TIMEOUT_DURATION: number;
	EVENT_END_TIMESTAMP: number;
	MINIMUM_GM_LEVEL_TO_TRADE: number;
	MINIMUM_GM_LEVEL_TO_USE_STORAGE: number;
	MINIMUM_GM_LEVEL_TO_USE_DUEY: number;
	MINIMUM_GM_LEVEL_TO_DROP: number;
	NPCS_SCRIPTABLE: java.util.Map;
	EXPEDITION_HWID_LIMIT: number;
}
interface PacketCreator {
	EMPTY_STATUPDATE: null[];
	ZERO_TIME: number;
	getTime(utcTimestamp: number): number;
	updateAriantPQRanking(e: java.util.Map): Packet;
	updateAriantPQRanking(chr: Character, score: number): Packet;
	getShowInventoryStatus(mode: number): Packet;
	updatePlayerStats(): Packet;
	serverMessage(message: string): Packet;
	getShowMesoGain(gain: number): Packet;
	getShowMesoGain(gain: number, inChat: boolean): Packet;
	getShowItemGain(p: number, itemId: number, quantity: boolean): Packet;
	getShowItemGain(itemId: number, quantity: number): Packet;
	killMonster(objId: number, animation: boolean): Packet;
	killMonster(objId: number, animation: number): Packet;
	getMiniGame(): Packet;
	onNewYearCardRes(i: Character, nSN: NewYearCardRecord, user: number, newyear: number): Packet;
	onNewYearCardRes(user: Character, cardId: number, mode: number, msg: number): Packet;
	getPlayerShop(s: PlayerShop, sold: boolean): Packet;
	removeItemFromMap(objId: number, animation: number, chrId: number): Packet;
	removeItemFromMap(objId: number, animation: number, chrId: number, pet: boolean, slot: number): Packet;
	addCashItemInformation(p: OutPacket, item: Item, accountId: number, giftMessage: string): void;
	addCashItemInformation(p: OutPacket, item: Item, accountId: number): void;
	moveMonsterResponse(objectid: number, moveid: number, currentMp: number, useSkills: boolean): Packet;
	moveMonsterResponse(objectid: number, moveid: number, currentMp: number, useSkills: boolean, skillId: number, skillLevel: number): Packet;
	viewMerchantBlacklist(chrName: java.util.Set): Packet;
	removeNPCController(objId: number): Packet;
	remoteChannelChange(ch: number): Packet;
	removeHiredMerchantBox(id: number): Packet;
	findMerchantResponse(map: boolean, extra: number): Packet;
	onCashGachaponOpenSuccess(accountid: number, sn: number, remainingBoxes: number, item: Item, itemid: number, nSelectedItemCount: number, bJackpot: boolean): Packet;
	getMiniGameMoveOmok(game: MiniGame, move1: number, move2: number, move3: number): Packet;
	sendNameTransferRules(error: number): Packet;
	showWorldTransferCancel(success: boolean): Packet;
	showAllCharacterInfo(chr: number, worldid: null[], chars: boolean): Packet;
	sendFamilyJoinResponse(accepted: boolean, added: string): Packet;
	MTSWantedListingOver(nx: number, items: number): Packet;
	showWorldTransferSuccess(item: Item, accountId: number): Packet;
	hiredMerchantOwnerMaintenanceLeave(): Packet;
	getMiniGameOwnerWin(game: MiniGame, forfeit: boolean): Packet;
	showForeignCardEffect(id: number): Packet;
	trockRefreshMapList(): Packet;
	updateHiredMerchant(item: HiredMerchant, hm: Character): Packet;
	sendFamilySummonRequest(familyName: string, from: string): Packet;
	showBoughtQuestItem(itemId: number): Packet;
	hiredMerchantOwnerLeave(): Packet;
	showCouponRedeemedItems(item: number, quantity: number, itemPair: number, accountId: null[], maplePoints: null[]): Packet;
	showNameChangeSuccess(item: Item, accountId: number): Packet;
	hiredMerchantVisitorAdd(chr: Character, slot: number): Packet;
	showForeignMakerEffect(cid: number, makerSucceeded: boolean): Packet;
	showMonsterBookPickup(): Packet;
	getMiniGameSkipVisitor(game: MiniGame): Packet;
	hiredMerchantMaintenanceMessage(): Packet;
	showBoughtCashPackage(item: null[], cashPackage: number): Packet;
	sendDueyParcelNotification(quick: boolean): Packet;
	viewMerchantVisitorHistory(pastVisitor: null[]): Packet;
	showNameChangeCancel(success: boolean): Packet;
	sendNameTransferCheck(availableName: string, canUseName: boolean): Packet;
	showForeignBuybackEffect(cid: number): Packet;
	sendWorldTransferRules(world: number, worlds: Client): Packet;
	onCashItemGachaponOpenFailed(): Packet;
	getMiniGameNewVisitor(minigame: MiniGame, chr: Character, slot: number): Packet;
	retrieveFirstMessage(): Packet;
	showEquipmentLevelUp(): Packet;
	getMatchCardNewVisitor(minigame: MiniGame, chr: Character, slot: number): Packet;
	getMiniGameVisitorWin(game: MiniGame, forfeit: boolean): Packet;
	getMiniGameSkipOwner(game: MiniGame): Packet;
	getMiniGameRemoveVisitor(): Packet;
	spawnHiredMerchantBox(hm: HiredMerchant): Packet;
	sendFamilyLoginNotice(name: string, loggedIn: boolean): Packet;
	sendDueyParcelReceived(from: string, quick: boolean): Packet;
	MobDamageMobFriendly(fixedMaxHP: Monster, fixedCurrHP: number, mob: number): Packet;
	showEventInstructions(): Packet;
	getMiniGameRequestTie(game: MiniGame): Packet;
	hiredMerchantVisitorLeave(slot: number): Packet;
	giveForeignPirateBuff(statup: number, cid: number, buffid: number, time: null[]): Packet;
	giveForeignWKChargeEffect(cid: number, buffid: number, statups: null[]): Packet;
	removePlayerShopBox(shop: PlayerShop): Packet;
	spawnNPCRequestController(life: NPC, miniMap: boolean): Packet;
	makeMonsterInvisible(life: Monster): Packet;
	sendMapleLifeCharacterInfo(): Packet;
	sendMapleLifeNameError(): Packet;
	stopControllingMonster(oid: number): Packet;
	updatePlayerShopBox(shop: PlayerShop): Packet;
	updateWitchTowerScore(score: number): Packet;
	removeQuestTimeLimit(quest: number): Packet;
	cancelForeignFirstDebuff(cid: number, mask: number): Packet;
	updateMapItemObject(drop: MapItem, giveOwnership: boolean): Packet;
	setExtraPendantSlot(toggleExtraSlot: boolean): Packet;
	cancelForeignDebuff(cid: number, mask: number): Packet;
	spawnPlayerMapObject(gs: Client, spawnPos: Character, i: boolean): Packet;
	silentRemoveItemFromMap(objId: number): Packet;
	giveForeignSlowDebuff(statup: number, chrId: null[], statups: MobSkill): Packet;
	updateInventorySlotLimit(type: number, newLimit: number): Packet;
	cancelForeignSlowDebuff(chrId: number): Packet;
	giveForeignChairSkillEffect(cid: number): Packet;
	cancelForeignChairSkillEffect(chrId: number): Packet;
	getPlayerShopNewVisitor(chr: Character, slot: number): Packet;
	removeMonsterInvisibility(life: Monster): Packet;
	requestPinAfterFailure(): Packet;
	sendCannotSpawnKite(): Packet;
	showAriantScoreBoard(): Packet;
	removePlayerFromMap(chrId: number): Packet;
	dropItemFromMapObject(player: Character, drop: MapItem, dropfrom: java.awt.Point, dropto: java.awt.Point, mod: number): Packet;
	updateHiredMerchantBox(hm: HiredMerchant): Packet;
	getPlayerShopRemoveVisitor(slot: number): Packet;
	getPlayerShopItemUpdate(item: PlayerShop): Packet;
	QuickslotMappedInit(pQuickslot: QuickslotBinding): Packet;
	environmentMoveReset(): Packet;
	updateBuddyCapacity(capacity: number): Packet;
	getPlayerShopOwnerUpdate(item: SoldItem, position: number): Packet;
	removeMessengerPlayer(position: number): Packet;
	giveFameErrorResponse(status: number): Packet;
	requestBuddylistAdd(chrIdFrom: number, chrId: number, nameFrom: string): Packet;
	showItemUnavailable(): Packet;
	updateMessengerPlayer(from: string, chr: Character, position: number, channel: number): Packet;
	getDimensionalMirror(talk: string): Packet;
	getShowInventoryFull(): Packet;
	getShowQuestCompletion(id: number): Packet;
	updatePartyMemberHP(cid: number, curhp: number, maxhp: number): Packet;
	cancelMonsterStatus(oid: number, stats: java.util.Map): Packet;
	environmentMoveList(envMove: java.util.Set): Packet;
	getTradeConfirmation(): Packet;
	getHiredMerchant(i: Character, stringBytePair: HiredMerchant, msgList: boolean): Packet;
	rpsSelection(selection: number, answer: number): Packet;
	removeMinigameBox(chr: Character): Packet;
	getMatchCardStart(): Packet;
	rpsMode(mode: number): Packet;
	hiredMerchantBox(): Packet;
	owlOfMinerva(owner: Client, ps: number, hm: null[]): Packet;
	fredrickMessage(operation: number): Packet;
	getMatchCardSelect(game: MiniGame, turn: number, slot: number, firstslot: number, type: number): Packet;
	getTradeChat(chr: Character, chat: string, owner: boolean): Packet;
	rpsMesoError(mesos: number): Packet;
	getFredrick(item: Character): Packet;
	getFredrick(op: number): Packet;
	addMatchCardBox(chr: Character, amount: number, type: number): Packet;
	getOwlMessage(msg: number): Packet;
	addOmokBox(chr: Character, amount: number, type: number): Packet;
	openRPSNPC(): Packet;
	getOwlOpen(i: null[]): Packet;
	getShowExpGain(gain: number, equip: number, party: number, inChat: boolean, white: boolean): Packet;
	getChatText(cidfrom: number, text: string, gm: boolean, show: number): Packet;
	spawnFakeMonster(life: Monster, effect: number): Packet;
	makeMonsterReal(life: Monster): Packet;
	getShowFameGain(gain: number): Packet;
	moveSummon(cid: number, oid: number, startPos: java.awt.Point, movementPacket: InPacket, movementDataLength: number): Packet;
	movePlayer(chrId: number, movementPacket: InPacket, movementDataLength: number): Packet;
	moveMonster(oid: number, skillPossible: boolean, skill: number, skillId: number, skillLevel: number, pOption: number, startPos: java.awt.Point, movementPacket: InPacket, movementDataLength: number): Packet;
	moveMonster2(oid: number, skillPossible: boolean, actionDir: number, data: number, startPos: java.awt.Point, movementPacket: InPacket, movementDataLength: number): Packet;
	summonAttack(attackEntry: number, cid: number, summonOid: number, direction: null[]): Packet;
	facialExpression(from: Character, expression: number): Packet;
	closeRangeAttack(chr: Character, skill: number, skilllevel: number, stance: number, numAttackedAndDamage: number, damage: java.util.Map, speed: number, direction: number, display: number): Packet;
	getNPCShop(item: Client, c: number, sid: null[]): Packet;
	throwGrenade(cid: number, pos: java.awt.Point, keyDown: number, skillId: number, skillLevel: number): Packet;
	shopTransaction(code: number): Packet;
	getScrollEffect(chr: number, scrollSuccess: ScrollResult, legendarySpirit: boolean, whiteScroll: boolean): Packet;
	magicAttack(chr: Character, skill: number, skilllevel: number, stance: number, numAttackedAndDamage: number, damage: java.util.Map, charge: number, speed: number, direction: number, display: number): Packet;
	rangedAttack(chr: Character, skill: number, skilllevel: number, stance: number, numAttackedAndDamage: number, projectile: number, damage: java.util.Map, speed: number, direction: number, display: number): Packet;
	deleteCharResponse(cid: number, state: number): Packet;
	updateCharLook(target: Client, chr: Character): Packet;
	showAllCharacter(totalWorlds: number, totalChrs: number): Packet;
	damagePlayer(skill: number, monsteridfrom: number, cid: number, damage: number, fake: number, direction: number, pgmr: boolean, pgmr_1: number, is_pg: boolean, oid: number, pos_x: number, pos_y: number): Packet;
	charNameResponse(charname: string, nameUsed: boolean): Packet;
	addNewCharEntry(chr: Character): Packet;
	selectWorld(world: number): Packet;
	catchMessage(message: number): Packet;
	sendMapleLifeError(code: number): Packet;
	addQuestTimeLimit(quest: number, time: number): Packet;
	showMonsterRiding(cid: number, mount: Mount): Packet;
	forfeitQuest(quest: number): Packet;
	giveBuff(statup: number, buffid: number, bufflength: null[]): Packet;
	charInfo(mg: Character): Packet;
	completeQuest(quest: number, time: number): Packet;
	updateQuestInfo(quest: number, npc: number): Packet;
	sendRecommended(world: null[]): Packet;
	getTradeItemAdd(number: number, item: Item): Packet;
	cancelDebuff(mask: number): Packet;
	getPlayerShopChat(chr: Character, chat: string, slot: number): Packet;
	getPlayerShopChat(chr: Character, chat: string, owner: boolean): Packet;
	updateQuest(iqs: Character, chr: QuestStatus, qs: boolean): Packet;
	getTradePartnerAdd(chr: Character): Packet;
	giveForeignDebuff(statup: number, chrId: null[], statups: MobSkill): Packet;
	cancelForeignBuff(chrId: number, statups: null[]): Packet;
	giveDebuff(statup: null[], statups: MobSkill): Packet;
	cancelBuff(statups: null[]): Packet;
	tradeInvite(chr: Character): Packet;
	getTradeMesoSet(number: number, meso: number): Packet;
	giveForeignBuff(statup: number, chrId: null[]): Packet;
	getNPCTalk(npc: number, msgType: number, talk: string, endBytes: string, speaker: number): Packet;
	getNPCTalkText(npc: number, talk: string, def: string): Packet;
	getNPCTalkStyle(style: number, npc: string, talk: number[]): Packet;
	OnAskQuiz(nSpeakerTypeID: number, nSpeakerTemplateID: number, nResCode: number, sTitle: string, sProblemText: string, sHintText: string, nMinInput: number, nMaxInput: number, tRemainInitialQuiz: number): Packet;
	getNPCTalkNum(npc: number, talk: string, def: number, min: number, max: number): Packet;
	getTradeStart(c: Client, trade: Trade, number: number): Packet;
	getTradeResult(number: number, operation: number): Packet;
	storeStorage(item: number, slots: InventoryType, type: null[]): Packet;
	showBerserk(chrId: number, skillLv: number, berserk: boolean): Packet;
	getInventoryFull(): Packet;
	showOwnBerserk(skilllevel: number, Berserk: boolean): Packet;
	OnAskSpeedQuiz(nSpeakerTypeID: number, nSpeakerTemplateID: number, nResCode: number, nType: number, dwAnswer: number, nCorrect: number, nRemain: number, tRemainInitialQuiz: number): Packet;
	showOwnBuffEffect(skillId: number, effectId: number): Packet;
	updateSkill(skillId: number, level: number, masterlevel: number, expiration: number): Packet;
	getKeymap(binding: java.util.Map): Packet;
	getStorageError(i: number): Packet;
	mesoStorage(slots: number, meso: number): Packet;
	partyStatusMessage(message: number, charname: string): Packet;
	partyStatusMessage(message: number): Packet;
	customShowBossHP(call: number, oid: number, currHP: number, maxHP: number, tagColor: number, tagBgColor: number): Packet;
	partyInvite(from: Character): Packet;
	receiveFame(mode: number, charnameFrom: string): Packet;
	showBossHP(oid: number, currHP: number, maxHP: number, tagColor: number, tagBgColor: number): Packet;
	takeOutStorage(item: number, slots: InventoryType, type: null[]): Packet;
	arrangeStorage(item: number, slots: null[]): Packet;
	showMonsterHP(oid: number, remhppercentage: number): Packet;
	partyCreated(mdo: Party, door: number): Packet;
	partySearchInvite(from: Character): Packet;
	giveFameResponse(mode: number, charname: string, newfame: number): Packet;
	multiChat(name: string, chattext: string, mode: number): Packet;
	applyMonsterStatus(stat: number, ref: MonsterStatusEffect, oid: null[]): Packet;
	getClockTime(hour: number, min: number, sec: number): Packet;
	spawnMobMist(objId: number, ownerMobId: number, msId: MobSkillId, mist: Mist): Packet;
	updateParty(forChannel: number, party: Party, op: PartyOperation, target: PartyCharacter): Packet;
	removeClock(): Packet;
	removeMist(objId: number): Packet;
	getClock(time: number): Packet;
	healMonster(oid: number, heal: number, curhp: number, maxhp: number): Packet;
	damageSummon(cid: number, oid: number, damage: number, monsterIdFrom: number): Packet;
	partyPortal(townId: number, targetId: number, position: java.awt.Point): Packet;
	cancelChair(id: number): Packet;
	showChair(characterid: number, itemid: number): Packet;
	showEffect(effect: string): Packet;
	itemEffect(characterid: number, itemid: number): Packet;
	spawnReactor(reactor: Reactor): Packet;
	updateBuddylist(buddy: null[]): Packet;
	updateBuddyChannel(characterid: number, channel: number): Packet;
	musicChange(song: string): Packet;
	destroyReactor(reactor: Reactor): Packet;
	environmentMove(env: string, mode: number): Packet;
	playSound(sound: string): Packet;
	buddylistMessage(message: number): Packet;
	triggerReactor(reactor: Reactor, stance: number): Packet;
	messengerInvite(from: string, messengerid: number): Packet;
	showPet(chr: Character, pet: Pet, remove: boolean, hunger: boolean): Packet;
	petChat(cid: number, index: number, act: number, text: string): Packet;
	removeMapEffect(): Packet;
	sendHint(hint: string, width: number, height: number): Packet;
	messengerChat(text: string): Packet;
	skillEffect(from: Character, skillId: number, level: number, flags: number, speed: number, direction: number): Packet;
	mapSound(path: string): Packet;
	startMapEffect(msg: string, itemId: number, active: boolean): Packet;
	OnCoupleMessage(fiance: string, text: string, spouse: boolean): Packet;
	messengerNote(text: string, mode: number, mode2: number): Packet;
	movePet(cid: number, pid: number, slot: number, moves: null[]): Packet;
	joinMessenger(position: number): Packet;
	addMessengerPlayer(from: string, chr: Character, position: number, channel: number): Packet;
	mapEffect(path: string): Packet;
	catchMonster(mobOid: number, success: number): Packet;
	catchMonster(mobOid: number, itemid: number, success: number): Packet;
	skillCancel(from: Character, skillId: number): Packet;
	commandResponse(cid: number, index: number, talk: boolean, animation: number, balloonType: boolean): Packet;
	skillBookResult(chr: Character, skillid: number, maxlevel: number, canuse: boolean, success: boolean): Packet;
	summonSkill(cid: number, summonSkillId: number, newStance: number): Packet;
	changePetName(chr: Character, newname: string, slot: number): Packet;
	showOwnPetLevelUp(index: number): Packet;
	showForcedEquip(team: number): Packet;
	petStatUpdate(i: Character): Packet;
	skillCooldown(sid: number, time: number): Packet;
	showPetLevelUp(chr: Character, index: number): Packet;
	petFoodResponse(cid: number, index: number, success: boolean, balloonType: boolean): Packet;
	getMacros(i: SkillMacro[]): Packet;
	loadExceptionList(ids: number, cid: number, petId: number, petIdx: null[]): Packet;
	getMatchCard(): Packet;
	getMiniGameTie(game: MiniGame): Packet;
	getMiniGameStart(game: MiniGame, loser: number): Packet;
	getMiniRoomError(status: number): Packet;
	getMiniGameDenyTie(game: MiniGame): Packet;
	getMiniGameClose(visitor: boolean, type: number): Packet;
	crogBoatPacket(type: boolean): Packet;
	getMiniGameUnReady(game: MiniGame): Packet;
	boatPacket(type: boolean): Packet;
	updateMount(charid: number, mount: Mount, levelup: boolean): Packet;
	getMiniGameReady(game: MiniGame): Packet;
	showCashShopMessage(message: number): Packet;
	takeFromCashInventory(item: Item): Packet;
	startMonsterCarnival(chr: Character, team: number, opposition: number): Packet;
	showBoughtCharacterSlot(slots: number): Packet;
	changeBackgroundEffect(remove: boolean, layer: number, transition: number): Packet;
	showBoughtInventorySlots(type: number, slots: number): Packet;
	putIntoCashInventory(item: Item, accountId: number): Packet;
	showBoughtStorageSlots(slots: number): Packet;
	modifyInventory(mod: boolean, updateTick: null[]): Packet;
	showBuffEffect(chrId: number, skillId: number, effectId: number, direction: number): Packet;
	showBuffEffect(chrId: number, skillId: number, effectId: number): Packet;
	showBuffEffect(chrId: number, skillId: number, skillLv: number, effectId: number, direction: number): Packet;
	spawnMist(objId: number, ownerId: number, skill: number, level: number, mist: Mist): Packet;
	environmentChange(env: string, mode: number): Packet;
	damageMonster(oid: number, damage: number): Packet;
	showCash(mc: Character): Packet;
	spawnNPC(life: NPC): Packet;
	getRelogResponse(): Packet;
	gachaponMessage(item: Item, town: string, player: Character): Packet;
	controlMonster(life: Monster, newSpawn: boolean, aggro: boolean): Packet;
	spawnMonster(life: Monster, newSpawn: boolean): Packet;
	spawnMonster(life: Monster, newSpawn: boolean, effect: number): Packet;
	byeAvatarMega(): Packet;
	removeKite(objId: number, animationType: number): Packet;
	getAvatarMega(s: Character, chr: string, medal: number, channel: number, itemId: null[], message: boolean): Packet;
	serverNotice(type: number, channel: number, message: string, smegaEar: boolean): Packet;
	serverNotice(type: number, channel: number, message: string): Packet;
	serverNotice(type: number, message: string): Packet;
	serverNotice(type: number, message: string, npc: number): Packet;
	sendDuey(): Packet;
	showSpecialEffect(effect: number): Packet;
	showForeignEffect(effect: number): Packet;
	showForeignEffect(chrId: number, effect: number): Packet;
	getStorage(item: number, npcId: number, slots: null[], items: number): Packet;
	showHpHealed(cid: number, amount: number): Packet;
	getPing(): Packet;
	getPermBan(reason: number): Packet;
	getHello(mapleVersion: number, sendIv: InitializationVector, recvIv: InitializationVector): Packet;
	getTempBan(timestampTill: number, reason: number): Packet;
	sendGuestTOS(): Packet;
	getLoginFailed(reason: number): Packet;
	getAfterLoginError(reason: number): Packet;
	sendPolice(): Packet;
	sendPolice(text: string): Packet;
	removeTV(): Packet;
	pinRegistered(): Packet;
	enableActions(): Packet;
	getServerList(ch: number, serverId: string, serverName: number, flag: string, eventmsg: null[]): Packet;
	registerPin(): Packet;
	getServerStatus(status: number): Packet;
	pinAccepted(): Packet;
	getServerIP(inetAddr: java.net.InetAddress, port: number, clientId: number): Packet;
	wrongPic(): Packet;
	getEndOfServerList(): Packet;
	requestPin(): Packet;
	getCharList(chr: Client, c: number, serverId: number): Packet;
	enableTV(): Packet;
	getChannelChange(inetAddr: java.net.InetAddress, port: number): Packet;
	getAuthSuccess(c: Client): Packet;
	sendTV(i: Character, chr: null[], messages: number, type: Character): Packet;
	getCharInfo(i: Character): Packet;
	spawnSummon(summon: Summon, animated: boolean): Packet;
	spawnKite(objId: number, itemId: number, name: string, msg: string, pos: java.awt.Point, ft: number): Packet;
	updatePlayerEXP(stats: number, enableActions: boolean): Packet;
	removeSummon(summon: Summon, animated: boolean): Packet;
	removeDoor(p: number, ownerId: boolean): Packet;
	spawnPortal(townId: number, targetId: number, pos: java.awt.Point): Packet;
	getWarpToMap(to: MapleMap, spawnPoint: number, chr: Character): Packet;
	getWarpToMap(to: MapleMap, spawnPoint: number, spawnPosition: java.awt.Point, chr: Character): Packet;
	spawnDoor(ownerid: number, pos: java.awt.Point, launched: boolean): Packet;
	hiredMerchantChat(message: string, slot: number): Packet;
	leaveHiredMerchant(slot: number, status2: number): Packet;
	spawnPlayerNPC(npc: PlayerNPC): Packet;
	getPlayerNPC(pos: PlayerNPC): Packet;
	sendYellowTip(tip: string): Packet;
	givePirateBuff(stat: null[], statups: number, buffid: number): Packet;
	sendMTS(j: null[], item: number, items: number, tab: number, type: number): Packet;
	removePlayerNPC(oid: number): Packet;
	notYetSoldInv(i: null[]): Packet;
	MTSFailBuy(): Packet;
	MTSConfirmBuy(): Packet;
	MTSConfirmTransfer(quantity: number, pos: number): Packet;
	transferInventory(i: null[]): Packet;
	useChalkboard(chr: Character, close: boolean): Packet;
	noteError(error: number): Packet;
	MTSConfirmSell(): Packet;
	showMTSCash(chr: Character): Packet;
	enableCSUse(mc: Character): Packet;
	getFindResult(target: Character, type: number, fieldOrChannel: number, flag: number): Packet;
	getFamilyInfo(entitlement: FamilyEntry): Packet;
	sendAutoHpPot(itemId: number): Packet;
	enableReport(): Packet;
	sendFamilyMessage(type: number, mesos: number): Packet;
	getItemMessage(itemid: number): Packet;
	addCard(full: boolean, cardid: number, level: number): Packet;
	giveFinalAttack(skillid: number, time: number): Packet;
	getWhisperResult(target: string, success: boolean): Packet;
	updateAreaInfo(area: number, info: string): Packet;
	updateGender(chr: Character): Packet;
	getGPMessage(gpChange: number): Packet;
	loadFamily(entitlement: Character): Packet;
	getWhisperReceive(sender: string, channel: number, fromAdmin: boolean, message: string): Packet;
	showPedigree(superJunior: FamilyEntry): Packet;
	showOXQuiz(questionSet: number, questionId: number, askQuestion: boolean): Packet;
	sendAutoMpPot(itemId: number): Packet;
	itemMegaphone(msg: string, whisper: boolean, channel: number, item: Item): Packet;
	showItemLevelup(): Packet;
	showRecovery(chrId: number, amount: number): Packet;
	showForeignInfo(cid: number, path: string): Packet;
	lockUI(enable: boolean): Packet;
	disableUI(enable: boolean): Packet;
	removeNPC(objId: number): Packet;
	changeCover(cardid: number): Packet;
	showInfo(path: string): Packet;
	showGainCard(): Packet;
	reportResponse(mode: number): Packet;
	sendHammerMessage(): Packet;
	openUI(ui: number): Packet;
	sendHammerData(hammerUsed: number): Packet;
	showOwnRecovery(heal: number): Packet;
	showIntro(path: string): Packet;
	aranGodlyStats(): Packet;
	playPortalSound(): Packet;
	showMakerEffect(makerSucceeded: boolean): Packet;
	showBuybackEffect(): Packet;
	updateQuestFinish(quest: number, npc: number, nextquest: number): Packet;
	showWheelsLeft(left: number): Packet;
	makerResultDesynth(item: number, itemId: number, mesos: null[]): Packet;
	disableMinimap(): Packet;
	questFailure(type: number): Packet;
	questExpire(quest: number): Packet;
	makerResultCrystal(itemIdGained: number, itemIdLost: number): Packet;
	getMultiMegaphone(): Packet;
	questError(quest: number): Packet;
	makerEnableActions(): Packet;
	showInfoText(text: string): Packet;
	makerResult(item: boolean, gem: number, success: number, itemMade: number, itemCount: null[], mesos: number, itemsLost: null[]): Packet;
	getGMEffect(type: number, mode: number): Packet;
	sendFamilyInvite(playerId: number, inviter: string): Packet;
	sendDueyMSG(operation: number): Packet;
	updateDojoStats(chr: Character, belt: number): Packet;
	levelUpMessage(type: number, level: number, charname: string): Packet;
	jobMessage(type: number, job: number, charname: string): Packet;
	removeItemFromDuey(remove: boolean, Package: number): Packet;
	marriageMessage(type: number, charname: string): Packet;
	sendDojoAnimation(firstByte: number, animation: string): Packet;
	trembleEffect(type: number, delay: number): Packet;
	sendMesoLimit(): Packet;
	getDojoInfo(info: string): Packet;
	blockedMessage(type: number): Packet;
	getSeniorMessage(name: string): Packet;
	getDojoInfoMessage(message: string): Packet;
	sendGainRep(gain: number, from: string): Packet;
	blockedMessage2(type: number): Packet;
	spawnGuide(spawn: boolean): Packet;
	talkGuide(talk: string): Packet;
	hpqMessage(text: string): Packet;
	coconutScore(team1: number, team2: number): Packet;
	rollSnowBall(entermap: boolean, state: number, ball0: Snowball, ball1: Snowball): Packet;
	finishedSort(inv: number): Packet;
	snowballMessage(team: number, message: number): Packet;
	bunnyPacket(): Packet;
	hitSnowBall(what: number, damage: number): Packet;
	dojoWarpUp(): Packet;
	leftKnockBack(): Packet;
	itemExpired(itemid: number): Packet;
	getEnergy(info: string, amount: number): Packet;
	hitCoconut(spawn: boolean, id: number, type: number): Packet;
	customPacket(packet: number[]): Packet;
	customPacket(packet: string): Packet;
	finishedSort2(inv: number): Packet;
	shopErrorMessage(error: number, type: number): Packet;
	earnTitleMessage(msg: string): Packet;
	refundCashItem(item: Item, maplePoints: number): Packet;
	showGifts(gift: null[]): Packet;
	guideHint(hint: number): Packet;
	showWishList(sn: Character, i: boolean): Packet;
	showBoughtCashItem(item: Item, accountId: number): Packet;
	deleteCashItem(item: Item): Packet;
	resetForcedStats(): Packet;
	showCashInventory(item: Client): Packet;
	showBoughtCashRing(ring: Item, recipient: string, accountId: number): Packet;
	openCashShop(sci: Client, snid: boolean): Packet;
	showGiftSucceed(to: string, item: CashItem): Packet;
	sendVegaScroll(op: number): Packet;
	showCombo(count: number): Packet;
	sheepRanchClothes(id: number, clothes: number): Packet;
	moveDragon(dragon: Dragon, startPos: java.awt.Point, movementPacket: InPacket, movementDataLength: number): Packet;
	playerSummoned(name: string, tab: number, number: number): Packet;
	sheepRanchInfo(wolf: number, sheep: number): Packet;
	pyramidGauge(gauge: number): Packet;
	CPUpdate(p: boolean, party: number, curCP: number, totalCP: number): Packet;
	spawnDragon(dragon: Dragon): Packet;
	playerDiedMessage(name: string, lostCP: number, team: number): Packet;
	incubatorResult(): Packet;
	pyramidScore(score: number, exp: number): Packet;
	setNPCScriptable(scriptableNpcIds: java.util.Map): Packet;
	CPQMessage(message: number): Packet;
	removeDragon(chrId: number): Packet;
}
interface TransactionService {
	getLastTransactions(transaction: number, rs: number): null[];
	convertTransactionItemsToItemPairs(item: null[]): null[];
	createTransactionItems(equip: number, transactionItemId: null[]): void;
	convertTransactionItemsToItems(transactionEquip: null[]): null[];
	updateTransactionBuybackStatus(affectedRows: number, preparedStatement: boolean): boolean;
	getTransactionSelectionListString(transaction: number): TransactionSelectionListStringResult;
	convertItemsToTransactionItems(equip: null[]): null[];
	deleteTransactionItems(transactionItemId: null[]): boolean;
	deleteTransaction(affectedRows: number): boolean;
	processTransaction(item: Character, transactionItems: number): string;
	createTransaction(rs: number): number;
	getTransactionById(rs: number): Transaction;
}
interface Transaction {
	getTotalPurchasePrice(): number;
	isBuybackUsed(): boolean;
	getItems(): null[];
	getTransactionId(): number;
	setTransactionDate(transactionDate: java.time.Instant): void;
	setUserId(userId: number): void;
	setTransactionId(transactionId: number): void;
	setBuybackUsed(buybackUsed: boolean): void;
	setItems(items: null[]): void;
	getTransactionDate(): java.time.Instant;
	getUserId(): number;
}
interface TransactionItem {
	getType(): number;
	getOwner(): string;
	setOwner(owner: string): void;
	getTransactionItemId(): number;
	getItemId(): number;
	setItemId(itemId: number): void;
	setType(type: number): void;
	setExpiration(expiration: number): void;
	setInventoryType(inventoryType: number): void;
	getGiftFrom(): string;
	getExpiration(): number;
	setQuantity(quantity: number): void;
	getPetId(): number;
	getPosition(): number;
	getInventoryType(): number;
	getFlag(): number;
	setPosition(position: number): void;
	setFlag(flag: number): void;
	setPetId(petId: number): void;
	setGiftFrom(giftFrom: string): void;
	getQuantity(): number;
	setTransactionItemId(transactionItemId: number): void;
}
interface TransactionEquip extends TransactionItem {
	getLevel(): number;
	setLevel(level: number): void;
	getStr(): number;
	setIntStat(intStat: number): void;
	getUpgradeSlots(): number;
	getLuk(): number;
	getHp(): number;
	setHp(hp: number): void;
	getMp(): number;
	setStr(str: number): void;
	getDex(): number;
	setUpgradeSlots(upgradeSlots: number): void;
	setDex(dex: number): void;
	setLuk(luk: number): void;
	setAvoid(avoid: number): void;
	getItemLevel(): number;
	setItemLevel(itemLevel: number): void;
	setMdef(mdef: number): void;
	setMp(mp: number): void;
	setVicious(vicious: number): void;
	getAvoid(): number;
	setRingId(ringId: number): void;
	setLocked(locked: number): void;
	setWatk(watk: number): void;
	setSpeed(speed: number): void;
	setAcc(acc: number): void;
	getHands(): number;
	getItemExp(): number;
	getWdef(): number;
	getAcc(): number;
	getMatk(): number;
	setWdef(wdef: number): void;
	getWatk(): number;
	setMatk(matk: number): void;
	setHands(hands: number): void;
	getSpeed(): number;
	setJump(jump: number): void;
	getJump(): number;
	getVicious(): number;
	setItemExp(itemExp: number): void;
	getRingId(): number;
	getMdef(): number;
	getIntStat(): number;
	getLocked(): number;
}
interface TransactionSelectionListStringResult {
	getMessage(): string;
	getResult(): boolean;
}



declare var cm: NPCConversationManager;
declare var im: NPCConversationManager; // Actually not longer ItemScriptManager
declare var ms: MapScriptManager;
declare var pi: PortalScriptManager;
declare var qm: QuestScriptManager;
declare var em: EventScriptManager;
declare var eim: EventInstanceManager;